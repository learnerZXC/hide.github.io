<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5新特性]]></title>
    <url>%2F2018%2F03%2F26%2FHTML5%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[HTML5学习笔记HTML5标签变化HTML &lt;!DOCTYPE&gt; 标签&lt;!DOCTYPE&gt; 声明必须是HTML的第一行，位于标签之前。 &lt;!DOCTYPE&gt;不是HTML标签，而是只是浏览器关于页面使用哪个HTML版本进行编写的指令。 常用的DOCTYPE声明： HTML 4.01 Strict:该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML 4.01 Transitional: 该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。 &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 4.01 Frameset:该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; HTML5&lt;!DOCTYPE html&gt; 注：在 HTML 4.01 中，&lt;!DOCTYPE&gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。 提示：请始终向 HTML 文档添加 &lt;!DOCTYPE&gt; 声明，这样浏览器才能获知文档类型。 新增的标签结构标签结构标签（块状元素）：可以认为是个有意义的div. &lt;article&gt; : 标记定义一篇文章 &lt;header&gt;: 标记定义一个页面或一个区域的头部 &lt;nav&gt;: 标记定义导航链接 &lt;section&gt;: 标记定义一个区域 &lt;aside&gt;: 标记定义页面内容部分的侧边栏 &lt;hgroup&gt;: 标记定义文件中一个区块的相关信息 &lt;figure&gt;: 标记定义一组媒体内容以及它们的标题 &lt;figcaption&gt;: 标记定义figure元素的标题 &lt;footer&gt;: 标记定义一个页面或一个区域的底部 &lt;dialog&gt;： 标记定义一个对话框（会话框）类似微信 补充： 1. header/section/aside/article/footer 最好不要互相嵌套在相同的标签里面（举例：header标签里面最好不要再嵌套个header标签） 2. 级别：header/section/footer &gt;aside/article/figure/hgroup/nav&gt;div/figcapition 多媒体标签 &lt;video&gt;: 标记定义一个视频。 &lt;audio&gt;: 标记定义音频内容。 &lt;source&gt;: 标记定义媒体资源。 &lt;canvas&gt;: 标记定义图片 &lt;embed&gt;: 标记定义外部可交互的内容或插件，比如flash。 标签意义：多媒体标签的出现意味着富媒体的发展以及支持不使用插件的情况下即可操作媒体文件，极大地提升了用户体验。 Web应用标签状态标签： &lt;meter&gt;: 状态标签（实时状态显示：气压、气温） 注： &lt;meter&gt;目前兼容的浏览器：Chrome、Opera &lt;progress&gt;: 状态标签（任务过程：安装、加载） 注： &lt;progress&gt;目前兼容的浏览器：Chrome、Firefox、Opera 列表标签： &lt;datalist&gt;: 为input标记定义一个下拉列表，配合option 注：&lt;datalist&gt;目前兼容的浏览器：Firefox、Opera &lt;details&gt;: 标记定义一个元素的详细内容，配合summary 注：&lt;details&gt;目前兼容的浏览器：Chrome Menu标签： &lt;menu&gt;: 命令列表（目前所有主流浏览器都不支持） &lt;menuitem&gt;: menu命令列表标签（只有FireFox8.0+支持） &lt;command&gt;: menu标记定义一个命令按钮（只有IE9支持） 其他标签注释标签： &lt;ruby&gt;: 标记定义注释或音标 &lt;rt&gt;: 标记定义对ruby的注释内容文本 &lt;rp&gt;: 告诉那些不支持ruby的浏览器该如何去显示 注：&lt;rp&gt;不要放在&lt;rt&gt;标签内 其他标签： &lt;mark&gt;: 标记定义有标记的文本（黄色选中状态） 注：IE9+ 、Chrome 等所有主流浏览器基本都可以实现 &lt;output&gt;: 标记定义一些输出类型，计算表单结果配合oninput事件 &lt;keygen&gt;: 标记定义表单里一个生成的键值（加密信息传递） &lt;time&gt;: 标记定义一个日期/时间，目前所有主流浏览器都不支持 删除的标签纯表现的元素： basefont、big、center、font、s、strike、tt、u 对可用性产生负面影响的元素 frame、frameeset、noframes 产生混淆的元素 acronym、applet、isindex、dir 重定义标签 &lt;b&gt;: 代表内联文本，通常是粗体，没有传递表示重要的意思 &lt;i&gt;: 代表内联文本，通常是斜体，没有传递表示重要的意思 &lt;dd&gt;（描述）: 可以同details与figure一同使用，定义包含文本，dialog也可用 &lt;dt&gt;（标题）: 可以同details与figure一同使用，汇总细节，dialog也可用 &lt;hr&gt;：表示主题结束，而不是水平线，虽然显示相同 &lt;menu&gt;: 重新定义用户界面的菜单，配合commond或menuitem使用 &lt;small&gt;: 表示小字体，例如打印注释或法律条款 &lt;strong&gt;: 表示重要性而不是强调符号]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML 5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2018%2F03%2F09%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[SpringBoot简介Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。 特点 化繁为简，简化配置 快速创建项目maven构建项目 访问http://start.spring.io/ 选择构建工具 Maven Project、编程语言Java、SpringBoot版本以及一些工程的基本信息。点击下方的Switch to the full version可以选择更多的信息以及勾选相关组件。 点击Generate Project下载项目压缩包。 解压后，使用Eclipse,Import———&gt;Maven——&gt;Existing Maven Projects ——&gt;Next——&gt;选择解压后的文件夹-&gt; Finsh 项目结构介绍 src/main/java: 程序开发以及主程序入口 src/main/resource: 配置文件 src/test/java: 测试程序 另外，SpringBoot建议目录如下： Application.java: 建议放在根目录下，主要用于一些框架配置 domain目录主要用于实体（Entity）与数据访问层（Repository） service 层主要是业务类代码 controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改。 启动Application main方法，至此一个java项目搭建好了！ 项目启动方式 src/main/java/包名/Application.java中直接run运行。 命令行启动: 进入项目路径：cd 项目路径，使用命令mvn spring-boot:run来启动 命令行启动: 进入项目路径：cd 项目路径，编译项目mvn install, 进入target文件夹cd traget, 然后使用java -jar 文件名来启动 项目属性配置推荐使用yml来配置项目]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hashcode()和equals()方法的作用？]]></title>
    <url>%2F2018%2F03%2F06%2Fhashcode-%E5%92%8Cequals-%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[hashcode()和equals()方法的作用？什么时候必须重写？ jdk中对equals()和hashcode()这两个方法的定义和规范如下：equals(Object obj)方法来判断两个对象是否相同？如果“相同”，则返回true,否则返回false. hashcode()方法返回一个int数，在Object中的默认实现是“将该对象的内存地址转换成一个整数返回”。Java中任何一个对象都具有equals()和Hashcode()方法，因为他们是在Object类中定义的。 hashcode()方法的作用：HashCode的存在主要是用于查找的快捷性，HashCode是用来在散列存储结构中确定对象的存储地址的； equals()方法的作用：equals()方法是来判断两个方法是否相同的。 关于这两个方法的重要规范： 如果两个对象相同，equals()方法一定返回true,并且这两个对象的hashcode一定相同。 如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置。 重新equals()方法是因为Object.equal()方法比较基本数据类型时是比较值是否相等，而比较引用类型时是“引用比较”。而实现者希望实现“值比较”，而不是默认的“引用比较”。（List和Set接口要求进行这样的值比较，所以得重新equals方法） 重新equals()方法必须重新hashcode()方法，为了满足hashcode()方法的常规协定。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Spring框架]]></title>
    <url>%2F2018%2F03%2F06%2FSpring%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java多线程--synchronized关键字]]></title>
    <url>%2F2018%2F03%2F06%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java多线程volatile关键字]]></title>
    <url>%2F2018%2F03%2F06%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java集合源码之ConcurrentHashMap]]></title>
    <url>%2F2018%2F02%2F04%2FJava%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E4%B9%8BConcurrentHashMap%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java集合之HashMap]]></title>
    <url>%2F2018%2F02%2F03%2FJava%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E4%B9%8BHashMap%2F</url>
    <content type="text"><![CDATA[Java集合之HashMap简介HashMap 基于哈希表的Map接口的实现。此实现提供所有可选的映射操作，并允许使用null值和null键。（除了非同步和允许使用null之外，HashMap类与Hashtable大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。 HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。 源码HashMap源码如下(基于jdk1.8.0_111)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903package java.util;import java.io.IOException;import java.io.InvalidObjectException;import java.io.Serializable;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.util.function.BiConsumer;import java.util.function.BiFunction;import java.util.function.Consumer;import java.util.function.Function;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; //序列化版本用 private static final long serialVersionUID = 362498820763181265L; //默认初始容量 = 16，且实际值必须是2的幂 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //最大容量（必须是2的幂且小于2的30次方，如果传入的值过大，则被该值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //填充因子，默认为0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; //一个桶中bin（箱子）的存储方式由链表转换成树的阈值。即当桶中bin的数量超过TREEIFY_THRESHOLD时使用树来代替链表。默认值是8 static final int TREEIFY_THRESHOLD = 8; //当执行resize操作时，当桶中bin的数量少于UNTREEIFY_THRESHOLD时使用链表来代替树。默认值是6 static final int UNTREEIFY_THRESHOLD = 6; //树的最小的容量，至少是 4 x TREEIFY_THRESHOLD = 32 然后为了避免(resizing 和 treeification thresholds) 设置成64 static final int MIN_TREEIFY_CAPACITY = 64; /** * Basic hash bin node, used for most entries. (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; //用来定位数组索引位置 final int hash; //键 final K key; //值 V value; //链表的下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; //返回键 public final K getKey() &#123; return key; &#125; //返回值 public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; //返回此映射项的哈希值:key值的哈希码与value值的哈希码按位异或的结果 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; //用指定值替换对应于此项的值,并返回旧值 public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; //比较指定对象与此项的相等性 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; if ((c = x.getClass()) == String.class) // bypass checks return c; if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; return null; &#125; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) // for cast to Comparable static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x)); &#125; //找出“大于Capacity”的最小的2的幂,使Hash表的容量保持为2的次方倍 //算法的思想：通过使用逻辑运算来替代取余，这里有一个规律，就是当N为2的次方（Power of two），那么X％N==X&amp;(N-1)。 static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; //&gt;&gt;&gt; 无符号右移,高位补0 n |= n &gt;&gt;&gt; 2; //a|=b的意思就是把a和b按位或然后赋值给a n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; // 三目运算符的嵌套 return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; //存放元素的数组 transient Node&lt;K,V&gt;[] table; //用来获取键值对 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //存放元素的个数，注意这个不等于数组的长度。 transient int size; //内部结构修改的次数，在迭代fail-fast机制时使用 transient int modCount; //扩容的临界值,当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 填充因子 final float loadFactor; // 指定初始容量和填充因子的构造方法 public HashMap(int initialCapacity, float loadFactor) &#123; // 指定的初始容量非负 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // 如果指定的初始容量大于最大容量,置为最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //填充因子为正 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); //设置填充因子 this.loadFactor = loadFactor; //指定容量后，tableSizeFor方法计算出临界值，put数据的时候如果超出该值就会扩容，该值肯定也是2的幂 // 指定的初始容量没有保存下来，只用来生成了一个临界值 this.threshold = tableSizeFor(initialCapacity); &#125; //构造函数，指定初始值 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; //构造函数，默认初始容量 public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; //包含“Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; //将m中的元素逐个添加到HashMap中 putMapEntries(m, false); &#125; //用于帮助实现Map.putAll()方法 和Map构造器，当evict=false时表示构造初始HashMap。 final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size();//得到指定Map的大小 if (s &gt; 0) &#123; if (table == null) &#123; // pre-size float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?//通过迭代器，将“m”中的元素逐个添加到HashMap中 (int)ft : MAXIMUM_CAPACITY);//得到按指定Map大小计算出的HashMap所需的容量 if (t &gt; threshold) //如果容量大于阈值 threshold = tableSizeFor(t); &#125; else if (s &gt; threshold) //指定Map的大小&gt;扩容临界值,扩容 resize(); //通过迭代器，将“m”中的元素逐个添加到HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125; &#125; //返回此映射中的键-值映射关系数 public int size() &#123; return size; &#125; //如果此映射不包含键-值映射关系，则返回 true public boolean isEmpty() &#123; return size == 0; &#125; //返回指定key所映射的value；如果对于该键来说，此映射不包含任何映射关系，则返回 null public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //key的哈希值为数组下标 if (first.hash == hash &amp;&amp; //检查第一个节点 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //如果第一个节点不对，则向后检查 if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; //如果此映射包含对于指定键的映射关系，则返回 true。 public boolean containsKey(Object key) &#123; return getNode(hash(key), key) != null; &#125; /** * 在此映射中关联指定值与指定键。如果该映射以前包含了一个该键的映射关系，则旧值被替换。 * * @param key 指定值将要关联的键 * @param value 指定键将要关联的值 * @return 与 key关联的旧值；如果 key没有任何映射关系，则返回 null。（返回 null 还可能表示该映射之前将null与 key关联。） */ //将key,value添加到HashMap中 public V put(K key, V value) &#123; //此处调用putVal方法，也调用了hash方法获取哈希值 return putVal(hash(key), key, value, false, true); &#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //此处分两种情况：1.当table为null时，用默认容量16初始化table数组；2.当table非空时 // 如果tab为空或长度为0，就通过resize方法创建 if ((tab = table) == null || (n = tab.length) == 0) //旧hash表为null或旧hash表长度为0 n = (tab = resize()).length; //初始化hash表的长度（16） //此处又分为两种情况：1.key的hash值对应的那个节点为空；2.key的hash值对应的那个节点不为空 if ((p = tab[i = (n - 1) &amp; hash]) == null) //该key的hash值对应的那个节点为空，即表示还没有元素被散列至此 tab[i] = newNode(hash, key, value, null);//则创建一个新的new Node&lt;&gt;(hash, key, value, next); else &#123; Node&lt;K,V&gt; e; K k; // 第一节节点hash值同，且key值与插入key相同，节点key存在，直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断该链为红黑树 else if (p instanceof TreeNode) // 红黑树的put方法比较复杂，putVal之后还要遍历整个树，必要的时候修改值来保证红黑树的特点 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; // e为空，表示已到表尾也没有找到key值相同节点，则新建节点 p.next = newNode(hash, key, value, null); // 新增节点后如果节点个数到达阈值，则将链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // key已经存在直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 更新hash值和key值均相同的节点Value值 if (e != null) &#123; V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //如果加入该键值对后超过最大阀值，则进行resize操作 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; //resize()方法作用有两种：1.初始化hash表的容量，为16； 2.将hash表容量翻倍 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //旧hash表 int oldCap = (oldTab == null) ? 0 : oldTab.length; //旧hash表容量 int oldThr = threshold; //旧hash表阈值 int newCap, newThr = 0; //新hash表容量与扩容临界值 2.旧hash表非空，则表容量翻倍 if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //更新扩容临界值 newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 计算新的resize上限 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //初始化hash表容量，设为默认值16 else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //创建一个初始容量为新hash表长度的newTab数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // //如果旧hash表非空，则按序将旧hash表中的元素重定向到新hash表 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; //e按序指向oldTab数组中的元素，即每个链表中的头结点 if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //如果链表只有一个头节点 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //对链表进行秩序维护：因为我们使用的是两倍扩容的方法，所以每个桶里面的元素必须要么待在原来的 //索引所对应的位置，要么在新的桶中位置偏移两倍 else &#123;// 链表优化重hash的代码块 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; //将桶内所有的 链表节点 替换成 红黑树节点 final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; //如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建/扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); //如果哈希表中的元素个数超过了 树形化阈值，进行树形化 // e 是哈希表中指定位置桶里的链表节点，从第一个开始 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; //新建一个树形节点，内容和当前链表节点 e 一致 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); //确定树头节点 if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); //让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了 if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; //将指定映射的所有映射关系复制到此映射中，这些映射关系将替换此映射目前针对指定映射中所有键的所有映射关系。 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true); &#125; //从此映射中移除指定键的映射关系（如果存在） public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; &#125; /** * 用于实现 Map.remove()方法和其他相关的方法 * * @param hash 键的hash值 * @param key 键 * @param value the value to match if matchValue, else ignored * @param matchValue if true only remove if value is equal * @param movable if false do not move other nodes while removing * @return the node, or null if none */ final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //table数组非空，键的hash值所指向的数组中的元素非空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; //node指向最终的结果结点，e为链表中的遍历指针 if (p.hash == hash &amp;&amp; //检查第一个节点，如果匹配成功 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; //如果第一个节点匹配不成功，则向后遍历链表查找 else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) //删除node结点 tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null; &#125; //从此映射中移除所有映射关系 public void clear() &#123; Node&lt;K,V&gt;[] tab; modCount++; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; size = 0; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; &#125; &#125; //如果此映射将一个或多个键映射到指定值，则返回 true。 public boolean containsValue(Object value) &#123; Node&lt;K,V&gt;[] tab; V v; if ((tab = table) != null &amp;&amp; size &gt; 0) &#123; //外层循环搜索数组 for (int i = 0; i &lt; tab.length; ++i) &#123; //内层循环搜索链表 for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if ((v = e.value) == value || (value != null &amp;&amp; value.equals(v))) return true; &#125; &#125; &#125; return false; &#125; //此映射中包含的键的 set 视图 public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks; &#125; final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; //返回此映射所包含的值的 Collection 视图。 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; if (vs == null) &#123; vs = new Values(); values = vs; &#125; return vs; &#125; final class Values extends AbstractCollection&lt;V&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public final boolean contains(Object o) &#123; return containsValue(o); &#125; public final Spliterator&lt;V&gt; spliterator() &#123; return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; //返回此映射所包含的映射关系的 Set 视图。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es; &#125; final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; public final boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Node&lt;K,V&gt; candidate = getNode(hash(key), key); return candidate != null &amp;&amp; candidate.equals(e); &#125; public final boolean remove(Object o) &#123; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o; Object key = e.getKey(); Object value = e.getValue(); return removeNode(hash(key), key, value, true, true) != null; &#125; return false; &#125; public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123; return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; &#125; // Overrides of JDK8 Map extension methods @Override public V getOrDefault(Object key, V defaultValue) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? defaultValue : e.value; &#125; @Override public V putIfAbsent(K key, V value) &#123; return putVal(hash(key), key, value, true, true); &#125; @Override public boolean remove(Object key, Object value) &#123; return removeNode(hash(key), key, value, true, true) != null; &#125; @Override public boolean replace(K key, V oldValue, V newValue) &#123; Node&lt;K,V&gt; e; V v; if ((e = getNode(hash(key), key)) != null &amp;&amp; ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123; e.value = newValue; afterNodeAccess(e); return true; &#125; return false; &#125; @Override public V replace(K key, V value) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) != null) &#123; V oldValue = e.value; e.value = value; afterNodeAccess(e); return oldValue; &#125; return null; &#125; @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; if (mappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; V oldValue; if (old != null &amp;&amp; (oldValue = old.value) != null) &#123; afterNodeAccess(old); return oldValue; &#125; &#125; V v = mappingFunction.apply(key); if (v == null) &#123; return null; &#125; else if (old != null) &#123; old.value = v; afterNodeAccess(old); return v; &#125; else if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); return v; &#125; public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); Node&lt;K,V&gt; e; V oldValue; int hash = hash(key); if ((e = getNode(hash, key)) != null &amp;&amp; (oldValue = e.value) != null) &#123; V v = remappingFunction.apply(key, oldValue); if (v != null) &#123; e.value = v; afterNodeAccess(e); return v; &#125; else removeNode(hash, key, null, false, true); &#125; return null; &#125; @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; V oldValue = (old == null) ? null : old.value; V v = remappingFunction.apply(key, oldValue); if (old != null) &#123; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); &#125; else if (v != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, v); else &#123; tab[i] = newNode(hash, key, v, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return v; &#125; @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; if (value == null) throw new NullPointerException(); if (remappingFunction == null) throw new NullPointerException(); int hash = hash(key); Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i; int binCount = 0; TreeNode&lt;K,V&gt; t = null; Node&lt;K,V&gt; old = null; if (size &gt; threshold || (tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123; if (first instanceof TreeNode) old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); else &#123; Node&lt;K,V&gt; e = first; K k; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; old = e; break; &#125; ++binCount; &#125; while ((e = e.next) != null); &#125; &#125; if (old != null) &#123; V v; if (old.value != null) v = remappingFunction.apply(old.value, value); else v = value; if (v != null) &#123; old.value = v; afterNodeAccess(old); &#125; else removeNode(hash, key, null, false, true); return v; &#125; if (value != null) &#123; if (t != null) t.putTreeVal(this, tab, hash, key, value); else &#123; tab[i] = newNode(hash, key, value, first); if (binCount &gt;= TREEIFY_THRESHOLD - 1) treeifyBin(tab, hash); &#125; ++modCount; ++size; afterNodeInsertion(true); &#125; return value; &#125; @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key, e.value); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; Node&lt;K,V&gt;[] tab; if (function == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; e.value = function.apply(e.key, e.value); &#125; &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; @SuppressWarnings("unchecked") @Override //返回此 HashMap 实例的浅表副本 public Object clone() &#123; HashMap&lt;K,V&gt; result; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); //调用父类clone方法 &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(e); &#125; result.reinitialize(); result.putMapEntries(this, false); //将此HashMap元素放入result中 return result; &#125; // These methods are also used when serializing HashSets final float loadFactor() &#123; return loadFactor; &#125; final int capacity() &#123; return (table != null) ? table.length : (threshold &gt; 0) ? threshold : DEFAULT_INITIAL_CAPACITY; &#125; //java.io.Serializable的写入函数,将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; int buckets = capacity(); // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); s.writeInt(buckets); s.writeInt(size); internalWriteEntries(s); &#125; //java.io.Serializable的读取函数：根据写入方式读出,将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException("Illegal load factor: " + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException("Illegal mappings count: " + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings("unchecked") K key = (K) s.readObject(); @SuppressWarnings("unchecked") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; Node&lt;K,V&gt; p = current; if (p == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); current = null; K key = p.key; removeNode(hash(key), key, null, false, false); expectedModCount = modCount; &#125; &#125; final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125; &#125; final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; &#123; public final V next() &#123; return nextNode().value; &#125; &#125; final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125; static class HashMapSpliterator&lt;K,V&gt; &#123; final HashMap&lt;K,V&gt; map; Node&lt;K,V&gt; current; // current node int index; // current index, modified on advance/split int fence; // one past last index int est; // size estimate int expectedModCount; // for comodification checks HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; this.map = m; this.index = origin; this.fence = fence; this.est = est; this.expectedModCount = expectedModCount; &#125; final int getFence() &#123; // initialize fence and size on first use int hi; if ((hi = fence) &lt; 0) &#123; HashMap&lt;K,V&gt; m = map; est = m.size; expectedModCount = m.modCount; Node&lt;K,V&gt;[] tab = m.table; hi = fence = (tab == null) ? 0 : tab.length; &#125; return hi; &#125; public final long estimateSize() &#123; getFence(); // force init return (long) est; &#125; &#125; static final class KeySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;K&gt; &#123; KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public KeySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.key); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; K k = current.key; current = current.next; action.accept(k); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; static final class ValueSpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;V&gt; &#123; ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public ValueSpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p.value); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; V v = current.value; current = current.next; action.accept(v); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0); &#125; &#125; static final class EntrySpliterator&lt;K,V&gt; extends HashMapSpliterator&lt;K,V&gt; implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est, int expectedModCount) &#123; super(m, origin, fence, est, expectedModCount); &#125; public EntrySpliterator&lt;K,V&gt; trySplit() &#123; int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1; return (lo &gt;= mid || current != null) ? null : new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1, expectedModCount); &#125; public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int i, hi, mc; if (action == null) throw new NullPointerException(); HashMap&lt;K,V&gt; m = map; Node&lt;K,V&gt;[] tab = m.table; if ((hi = fence) &lt; 0) &#123; mc = expectedModCount = m.modCount; hi = fence = (tab == null) ? 0 : tab.length; &#125; else mc = expectedModCount; if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp; (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123; Node&lt;K,V&gt; p = current; current = null; do &#123; if (p == null) p = tab[i++]; else &#123; action.accept(p); p = p.next; &#125; &#125; while (p != null || i &lt; hi); if (m.modCount != mc) throw new ConcurrentModificationException(); &#125; &#125; public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123; int hi; if (action == null) throw new NullPointerException(); Node&lt;K,V&gt;[] tab = map.table; if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123; while (current != null || index &lt; hi) &#123; if (current == null) current = tab[index++]; else &#123; Node&lt;K,V&gt; e = current; current = current.next; action.accept(e); if (map.modCount != expectedModCount) throw new ConcurrentModificationException(); return true; &#125; &#125; &#125; return false; &#125; public int characteristics() &#123; return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) | Spliterator.DISTINCT; &#125; &#125; // Create a regular (non-tree) node Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next); &#125; // For conversion from TreeNodes to plain nodes Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(p.hash, p.key, p.value, next); &#125; // Create a tree bin node TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(hash, key, value, next); &#125; // For treeifyBin TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next); &#125; void reinitialize() &#123; table = null; entrySet = null; keySet = null; values = null; modCount = 0; threshold = 0; size = 0; &#125; // Callbacks to allow LinkedHashMap post-actions void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125; void afterNodeInsertion(boolean evict) &#123; &#125; void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; // Called only from writeObject, to ensure compatible ordering. void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123; Node&lt;K,V&gt;[] tab; if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; s.writeObject(e.key); s.writeObject(e.value); &#125; &#125; &#125; &#125; static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; int n; if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123; int index = (n - 1) &amp; root.hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index]; if (root != first) &#123; Node&lt;K,V&gt; rn; tab[index] = root; TreeNode&lt;K,V&gt; rp = root.prev; if ((rn = root.next) != null) ((TreeNode&lt;K,V&gt;)rn).prev = rp; if (rp != null) rp.next = rn; if (first != null) first.prev = root; root.next = first; root.prev = null; &#125; assert checkInvariants(root); &#125; &#125; /** * Finds the node starting at root p with the given hash and key. * The kc argument caches comparableClassFor(key) upon first use * comparing keys. */ final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null; &#125; final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null); &#125; static int tieBreakOrder(Object a, Object b) &#123; int d; if (a == null || b == null || (d = a.getClass().getName(). compareTo(b.getClass().getName())) == 0) d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -1 : 1); return d; &#125; final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root); &#125; final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; Node&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123; Node&lt;K,V&gt; p = map.replacementNode(q, null); if (tl == null) hd = p; else tl.next = p; tl = p; &#125; return hd; &#125; final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125; &#125; final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r); &#125; final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; r, pp, rl; if (p != null &amp;&amp; (r = p.right) != null) &#123; if ((rl = p.right = r.left) != null) rl.parent = p; if ((pp = r.parent = p.parent) == null) (root = r).red = false; else if (pp.left == p) pp.left = r; else pp.right = r; r.left = p; p.parent = r; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; TreeNode&lt;K,V&gt; l, pp, lr; if (p != null &amp;&amp; (l = p.left) != null) &#123; if ((lr = p.left = l.right) != null) lr.parent = p; if ((pp = l.parent = p.parent) == null) (root = l).red = false; else if (pp.right == p) pp.right = l; else pp.left = l; l.right = p; p.parent = l; &#125; return root; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; x.red = true; for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123; if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (!xp.red || (xpp = xp.parent) == null) return root; if (xp == (xppl = xpp.left)) &#123; if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; xppr.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.right) &#123; root = rotateLeft(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateRight(root, xpp); &#125; &#125; &#125; &#125; else &#123; if (xppl != null &amp;&amp; xppl.red) &#123; xppl.red = false; xp.red = false; xpp.red = true; x = xpp; &#125; else &#123; if (x == xp.left) &#123; root = rotateRight(root, x = xp); xpp = (xp = x.parent) == null ? null : xp.parent; &#125; if (xp != null) &#123; xp.red = false; if (xpp != null) &#123; xpp.red = true; root = rotateLeft(root, xpp); &#125; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123; if (x == null || x == root) return root; else if ((xp = x.parent) == null) &#123; x.red = false; return x; &#125; else if (x.red) &#123; x.red = false; return root; &#125; else if ((xpl = xp.left) == x) &#123; if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123; xpr.red = false; xp.red = true; root = rotateLeft(root, xp); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right; if ((sr == null || !sr.red) &amp;&amp; (sl == null || !sl.red)) &#123; xpr.red = true; x = xp; &#125; else &#123; if (sr == null || !sr.red) &#123; if (sl != null) sl.red = false; xpr.red = true; root = rotateRight(root, xpr); xpr = (xp = x.parent) == null ? null : xp.right; &#125; if (xpr != null) &#123; xpr.red = (xp == null) ? false : xp.red; if ((sr = xpr.right) != null) sr.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateLeft(root, xp); &#125; x = root; &#125; &#125; &#125; else &#123; // symmetric if (xpl != null &amp;&amp; xpl.red) &#123; xpl.red = false; xp.red = true; root = rotateRight(root, xp); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl == null) x = xp; else &#123; TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right; if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red)) &#123; xpl.red = true; x = xp; &#125; else &#123; if (sl == null || !sl.red) &#123; if (sr != null) sr.red = false; xpl.red = true; root = rotateLeft(root, xpl); xpl = (xp = x.parent) == null ? null : xp.left; &#125; if (xpl != null) &#123; xpl.red = (xp == null) ? false : xp.red; if ((sl = xpl.left) != null) sl.red = false; &#125; if (xp != null) &#123; xp.red = false; root = rotateRight(root, xp); &#125; x = root; &#125; &#125; &#125; &#125; &#125; static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right, tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next; if (tb != null &amp;&amp; tb.next != t) return false; if (tn != null &amp;&amp; tn.prev != t) return false; if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right) return false; if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash)) return false; if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash)) return false; if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red) return false; if (tl != null &amp;&amp; !checkInvariants(tl)) return false; if (tr != null &amp;&amp; !checkInvariants(tr)) return false; return true; &#125; &#125;&#125; HashMap原理总结HashMap基于Hash算法，通过put(key,value)来存储数值，通过get(key)来获取对应的value值。当HashMap保存对应的key-value时，HashMap会根据hash(key)[(h=key.hashCode())^(h&gt;&gt;&gt;16)]计算对应的hash值，然后根据hash值将value保存到table中。HashMap是使用哈希来存储数据，当使用hasn表时有可能产生hasn冲突，HashMap通过链表和红黑树来解决hasn冲突，来存储相同hash值的value。当Hash冲突的个数比较少时使用链表（默认为8个），否则使用红黑树]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合之Map接口]]></title>
    <url>%2F2018%2F02%2F03%2FJava%E9%9B%86%E5%90%88%E4%B9%8BMap%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Java集合之Map接口简介public interface Map&lt;K,V&gt; Map是将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。 方法及其介绍 clear():从此映射中移除所有映射关系（可选操作）。 返回值类型：无返回值 containsKey(Object key)：如果此映射包含指定键的映射关系，则返回 true。 返回值类型：boolean类型 containsKey(Object value)：如果此映射将一个或多个键映射到指定值，则返回 true。 返回值类型：boolean类型 entrySet():返回此映射中包含的映射关系的 Set 视图。 返回值类型：Set&lt;Map.Entry&gt; equals(Object o):比较指定的对象与此映射是否相等。 返回值类型：boolean类型 get(Object Key):返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。 返回值类型：V hashCode():返回此映射的哈希码值 返回值类型：int isEmpty:如果此映射未包含键-值映射关系，则返回 true。 返回值类型：boolean KeySet():返回此映射中包含的键的 Set 视图。 返回值类型：Set put(K key,V value): 将指定的值与此映射中的指定键关联（可选操作）。 返回值类型：V putAll(Map&lt;? extends K,? extends V&gt; m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。 返回值类型：无返回值 remove(Object key):如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。 返回值类型：V size():返回此映射中的键-值映射关系数，如果该映射包含的元素大于 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE。 返回值类型：int values:返回此映射中包含的值的 Collection 视图。 返回值类型：Collection]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Map接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合之Collection接口]]></title>
    <url>%2F2018%2F02%2F03%2FJava%E9%9B%86%E5%90%88%E4%B9%8BCollection%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Java集合之Collection接口简介public interface Collection&lt;E&gt;extends Iterable&lt;E&gt; Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 方法及其介绍 add(E e): 确保此 collection 包含指定的元素（可选操作）。如果此 collection 由于调用而发生更改，则返回 true。（如果此 collection 不允许有重复元素，并且已经包含了指定的元素，则返回 false。） 返回： boolean类型 remove(Object o): 从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。更确切地讲，如果此 collection 包含一个或多个满足 (o==null ? e==null : o.equals(e)) 的元素 e，则移除这样的元素。如果此 collection 包含指定的元素（或者此 collection 由于调用而发生更改），则返回 true 。 返回：boolean类型 size(): 返回此 collection 中的元素数。如果此 collection 包含的元素大于 Integer.MAX_VALUE，则返回 Integer.MAX_VALUE。 返回：int类型 isEmpty(): 如果此 collection 不包含元素，则返回 true。 返回：boolean类型 contains(Object o): 如果此 collection 包含指定的元素，则返回 true。更确切地讲，当且仅当此 collection 至少包含一个满足 (o==null ? e==null : o.equals(e)) 的元素 e 时，返回 true。 返回： boolean类型 iterator(): 返回在此 collection 的元素上进行迭代的迭代器。关于元素返回的顺序没有任何保证（除非此 collection 是某个能提供保证顺序的类实例）。 返回： Iterator toArray(): 返回包含此 collection 中所有元素的数组。 返回： 包含此 collection 中所有元素的数组。 constainsAll(): 如果此 collection 包含指定 collection 中的所有元素，则返回 true。 返回：boolean类型 addAll(Collection&lt;? extends E&gt; c):将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。如果在进行此操作的同时修改指定的 collection，那么此操作行为是不确定的。（这意味着如果指定的 collection 是此 collection，并且此 collection 为非空，那么此调用的行为是不确定的。） 返回： 如果此 collection 由于调用而发生更改，则返回 true removeAll(Collection&lt;?&gt; c): 移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。此调用返回后，collection 中将不包含任何与指定 collection 相同的元素。 返回： 如果此 collection 由于调用而发生更改，则返回 true retainAll(Collection&lt;?&gt; c): 仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。换句话说，移除此 collection 中未包含在指定 collection 中的所有元素。 返回： 如果此 collection 由于调用而发生更改，则返回 true clear(): 移除此 collection 中的所有元素（可选操作）。此方法返回后，除非抛出一个异常。 返回： 无返回值。 equals(Object o): 比较此 collection 与指定对象是否相等。 返回：如果指定对象与此 collection 相等，则返回 true hashCode()：返回此 collection 的哈希码值。 返回：此 collection 的哈希码值（int类型）]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合]]></title>
    <url>%2F2018%2F02%2F03%2FJava%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[Java集合]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合综述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（二）-线程的基本方法]]></title>
    <url>%2F2018%2F02%2F03%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[currentThread()方法currentThread（）方法可返回代码段正在被哪个线程调用的信息 isAlive()方法isAlive()方法是判断线程是否处于活动状态。 sleep（）方法sleep()方法的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）。这个“正在执行的线程”是指this.currentThread（）返回的线程。 getId()方法getId()方法作用是取得线程的唯一标识 getName()方法getName方法是取得线程的名称。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（三）-停止线程]]></title>
    <url>%2F2018%2F02%2F03%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[停止线程Java中有以下3种方法可以终止正在运行的线程： 使用退出标志，使线程正常退出，也就是当run方法完成后终止线程。 使用stop方法强行终止线程，但不推荐使用该方法，因为stop和suspend及resume方法一样，都是作废过期的方法，使用它们可能产生不可预料的结果。 使用interrupt方法终止线程。 判断线程是否是停止状态Thread类中提供了两种方法判断线程是否停止： this.interrupted():测试当前线程是否是中断状态（当前宣布从是指运行this.interrupted()方法的线程）。执行后具有将状态标志清楚为false的功能。 this.isInterrupted():测试线程Thread对象是否是中断状态，但不清除状态标志。 如何停止线程呢调用interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。仅仅是在当前线程中打了一个停止的标记，并不是真正的停止线程。 能停止线程的方法——异常法 可在线程中用for语句来判断一下线程是否是停止状态，如果是停止状态，则后面的代码不再运行即可，如果直接使用for+break，只是会停止循环，后面代码还会继续运行。如何解决语句继续运行的问题呢？在for循环中抛出异常即可。实例如下： MyThread.java代码如下：123456789101112131415161718192021package exthread;public class Mythread extends Thread&#123; @override public void run()&#123; super.run(); try&#123; for(int i = 0; i &lt; 500000; i++)&#123; if(this.interrupted())&#123; System.out.println("已经是停止状态了！ 我要退出了！")； //break; throw new InterruptedException(); &#125; System.out.println("i=" +(i+1))； &#125; System.out.println("我在for下面") &#125; catch(InterruptedException)&#123; System.out.println("进入MyThread.java类run的catch了！")； e.printStackTrace(); &#125; &#125;&#125; 类Run.java代码如下：123456789101112131415package test;import extherad.MyThread;public class Run&#123; public static void main(String[] args)&#123; try&#123; MyThread thread = new MyThread(); thread.start(); Thread.sleep(2000); thread.interrupt(); &#125;catch(InterruptedException e)&#123; System.out.println("main catch"); e.printStackTrack(); &#125; &#125;&#125; 如果直接使用for+break语句，虽然for循环会停止；但是“我在for下面还是会输出”。如果使用抛异常方法。则for循环后面的语句也不会执行。达到停止线程效果。 在沉睡中停止 123456789public class MyThread extends Thread &#123; @override public void run ()&#123; super.run(); try&#123; System.out.println("run begin"); &#125; &#125;&#125; 使用return停止 暴力停止-]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程（一）-了解多线程]]></title>
    <url>%2F2018%2F02%2F03%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是线程？什么是进程？进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,是系统进行资源分配和调度的一个独立单位，在“window任务管理器”中，我们完全可以将运行在内存中的exe文件看成进程。 线程可以理解为在进程中独立运行的子任务。比如QQ.exe运行时就可以有很多子任务同时运行，传输文件线程、发送消息线程等，这些不同的任务或者说功能都可以同时运行，其中每项任务都可以理解为一个线程在工作。 线程跟进程有啥区别？为什么要使用多线程？线程和进程最主要的区别在于他们操作系统的资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下对不会对其他进程产生影响。而线程是进程中的不同执行任务，线程有自己的堆栈和局部变量，但是没有独立的地址空间，一个线程死掉就相当于整个进程死掉。 一个程序至少有一个进程，一个进程至少有一个线程。 线程的划分尺度小于进程，一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。在进程内创建、终止线程比创建、终止进程要快；同一进程内的线程间切换比进程间的切换要快,尤其是用户级线程间的切换。 线程的实现学习如何创建线程前，先看下Thread类的结构，如下： public class Thread implements Runnable 从上面的源码可以看出，Thread类实现了Runnable接口，它们之间具有多态性。使用继承Thread类的方式创建新线程时，最大的局限就是不支持多继承，Java语言的特点是单根继承，所以为了支持多继承，完全可以实现Runnable接口的方式，一边实现一边继承。但使用两种方式创建的线程在工作时的性质是一致的，没有本质的区别。 继承Thread 创建一个自定义线程MyThread.java,此类继承Thread,并重新run方法，在run方法中，写线程要执行的代码： public class MyThread extends Thread{ @override public void run(){ super.run; System.out.println(&quot;MyThread&quot;); } } 实现Runnable接口继续创建创建一个实现Runnable接口的类MyRunnable,代码如下：12345678910111213141516public class MyRunnable implements Runnable&#123; @override public void run ()&#123; System.out.println("aaaa"); &#125;&#125;public class Run&#123; public staic void main(String[] args)&#123; Runnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); thread.start(); System.out.println("bb"); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript正则表达式]]></title>
    <url>%2F2018%2F02%2F03%2FJavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JavaScript正则表达式概念正则表达式（Regular Expression）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。简单来讲就是按照某种规则去匹配符合条件的字符串。 JavaScript正则表达式语法RegExp修饰符 g:全文搜索 i:忽略大小写 m:多行搜索ES6中新增修饰符： y:全局匹配，和g修饰符一样可以被执行多次，lastIndex移动到匹配位置的下一个位置。不同的地方在于y修饰符必须在开始的位置匹配，g修饰符只要在剩余的部分有匹配就可以。例如：let s = &#39;bbbb_bbb_bb_b&#39;;var a1 = /b+/g;var a2 = /b+/y;console.log(a1.exec(s), a2.exec(s)); // [&quot;bbbb&quot;],[&quot;bbbb&quot;]console.log(a1.exec(s), a2.exec(s)); // [&quot;bbb&quot;],nullconsole.log(a1.sticky, a2.sticky); //false,true表示是否开启了粘连模式ES6新增RegExp.sticky属性来判断是否开启粘连模式（y属性）,如上面所示 u:Unicode模式。用来正确处理大于0xFFFF的Unicode字符。例如：console.log(/\u{61}/.test(&#39;a&#39;)); // falseconsole.log(/\u{61}/u.test(&#39;a&#39;)); // true识别Unicode编码console.log(&#39;u修饰符&#39;,/^\uD83D/.test(&#39;\uD83D\uDC2A&#39;)); // trueconsole.log(&#39;u修饰符&#39;,/^\uD83D/u.test(&#39;\uD83D\uDC2A&#39;)); // false上面代码中，\uD83D\uDC2A 是一个四字节的UTF-16 编码，代表一个字符，但是，ES5不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第一行代码结果为 true ，加了u修饰符以后，ES6就会识别其为一个字符，所以第二行代码结果为false。注：点（.）字符不能识别码点大于0xFFFF的Unicode字符，必须加上u修饰符。使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。例如：console.log(/\u{20BB7});//𠮷let s = &#39;𠮷&#39;;console.log(&#39;大于0xFFFF的Unicode字符&#39;,/^.$/.test(s)); // false console.log(&#39;使用u字符&#39;,/^.$/u.test(s)); // trueconsole.log(&#39;量词&#39;,/a{2}/.test(&#39;aa&#39;)); // trueconsole.log(&#39;量词&#39;,/a{2}/u.test(&#39;aa&#39;)); // trueconsole.log(&#39;量词&#39;,/𠮷{2}/.test(&#39;𠮷𠮷&#39;)); // falseconsole.log(&#39;量词&#39;,/𠮷{2}/u.test(&#39;𠮷𠮷&#39;)); // true s只是提案，并不支持 RegExp对象JavaScript通过内置对象RegExp支持正则表达式有两种方式实例化RegExp对象： 字面量var reg = /\bis\b/g(\b单词边界) //第一个参数是正则表达式，不接受第二个参数，否则会报错&#39;He is a body. This is a dog. Where is she?&#39;.replace(reg,&#39;IS&#39;)结果为&quot;He IS a body. This IS a dog. Where IS she?&quot; 构造函数var reg = new RegExp(&#39;\\bis\\b&#39;,&#39;g&#39;)//第一个参数是字符串，第二个是修饰符&#39;He is a body. This is a dog. Where is she?&#39;.replace(reg,&#39;IS&#39;)结果为&quot;He IS a body. This IS a dog. Where IS she?&quot;ES6中新增了一种写法：let regexp = new RegExp(/xyz/ig,&#39;i&#39;)//原有正则对象的修饰符是ig，它会被第二个参数i覆盖同时新增：RegExp.flags获取正则对象修饰符的属性 JavaScript正则表达式元字符正则表达式由两种基本字符类型组成： 原义文本字符代表单词原本意义的字符 元字符元字符是在正则表达式中有特殊含义的非字母字符。注：元字符的含义并不是唯一的，在不同的环境下有不同的含义。* + ? $ ^ . | \ () {} []（这些元字符的意义见下面详解）\t: 水平制表符\v: 垂直制表符\n: 换行符\r: 回车符\0: 空字符\f: 换页符\cX: 与X对应的控制字符(Ctrl + X) 字符类一般情况下正则表达式一个字符对应字符串一个字符我们可以使用元字符[]来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符。例：表达式[abc]把字符a或b或c归为一类，表达式可以匹配这类字符。是指属于a或b或c中的一个即为匹配。 字符类取反使用元字符^创建反向类/负向类，便是不属于某类的类容例：[^abc]指不属于字符a或b或c的内容 范围类 我们可以使用[a-z]来连接两个字符表示从a到z的任意字符注：这是闭区间，也就是包括a和z本身 在[]组成的类内部是可以连写的[a-zA-Z] 如果要匹配的字符中包含-，直接加在后面即可[a-z-] 预定义类 .等价类：[^\r\n] 含义：除了回车和换行之外小于两个字节（小于0xFFFF）的所有字符 \d等价类：[0-9] 含义：数字字符 \D等价类：[^0-9] 含义：非数字字符 \s等价类：[\t\n\x0B\f\r] 含义：空白符 \S等价类：[^\t\n\x0B\f\r] 含义：非空白符 \w等价类：[a-zA-Z_0-9] 含义：单词字符 \W等价类：[^a-zA-Z_0-9] 含义：非单词字符常见的边界匹配的字符： ^含义：以xxx开始 $含义：以xxx结束 \b含义：单词边界 \B含义：非单词边界 量词 字符：? 含义：出现零次或一次（最多出现一次） 字符：+ 含义：出现一次或多次（最少出现一次） 字符：* 含义：出现零次或多次（任意次） 字符：{n} 含义：出现n次 字符：{n,m} 含义：出现n到m次 字符：{n,} 含义：至少出现n次 JS正则表达式贪婪模式和非贪婪模式 贪婪模式：正则表达式尽可能多的匹配，默认为贪婪模式例：var reg = / \d{3，6}/g&#39;12345678&#39;.replace(reg,&#39;X&#39;)结果为&#39;X78&#39; 非贪婪模式：让正则表达式尽可能少的匹配，也就是说一旦匹配成功匹配不在继续尝试。做法：在量词后加上?即可。例：var reg = / \d{3，6}?/g&#39;12345678&#39;.replace(reg,&#39;X&#39;)结果为&#39;XX78&#39; 分组使用()可以达到分组的功能，使量词作用于分组 或:使用|可以达到或的效果 反向引用：2015-12-25 =&gt; 12/25/20152015-12-25.replace(/(\d{4})-(\d{2})-(\d{2})/g,&#39;$2/$3/$1&#39;) 忽略分组：不想捕获某些分组，只需在分组内加?:即可例：(?:\d{2})表示忽略此分组 前瞻正则表达式从文本头部向尾部开始解析，文本尾部方向，称为“前”。前瞻就是正则表达式匹配到规则时，向前检查是否符合断言，后顾/后瞻方向相反注：JavaScript不支持后瞻符合和不符合特定断言称为肯定/正向匹配和否定/负向匹配 正向前瞻：exp(?=assert)例：a2*34vv.replace(/\w(?=\d)/g,&#39;X&#39;)结果为&#39;X2*X4vv&#39;注：断言部分不属于匹配的字符，只是判断规则 负向前瞻：exp(?!assert) 正向后顾：exp(?&lt;=assert) JavaScript不支持 负向后顾：exp(?&lt;!assert)JavaScript不支持 JS正则表达式对象属性 global:是否全文搜索，默认为flase（在后面加g开启） ignore case:是否大小写敏感。默认flase（在后面加i开启） multiline:多行搜索，默认值是false（在后面加m开启） lastIndex:是当前表达式匹配内容的最后一个字符的下一个位置 source:正则表达式的文本字符串 JS正则表达式方法 RegExp.prototype.test(str)作用：测试字符串参数中是否存在匹配正则表达式模式的字符串。返回值：存在返回true，否则返回false注：该方法使用完后会影响regExp的lastIndex属性，如果多次测试不建议使用 RegExp.prototype.exec(str)作用：使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反应匹配结果返回值：如果没有匹配的文本则返回null,否则返回一个结果数组： index声明匹配文本的第一个字符的位置 input存放被检索的字符串string 非全局调用：（在非全局下lastIndex不生效） 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式相匹配（分组）的文本（如果有的话），以此类推 全局调用：除了lastIndex生效外，其余与非全局调用相同 字符串的对象方法 String.prototype.search(reg)作用：search()方法用于检索字符串字符中指定的子字符串，或检索与正则表达式相匹配的子字符串。返回值：方法返回第一个匹配结果index，查找不到返回-1.注：search()方法不执行全局搜索，它将忽略标志g,并且总是从字符串的开始进行检索 String.prototype.match(reg)作用：match()方法将检索字符串，以找到一个或多个regexp匹配的文本注：regexp是否具有全局（g）对结果影响很大 非全局调用（在非全局下lastIndex不生效）match()方法就只能在字符串中执行一次返回值：如果没有任何匹配的文本，返回null,否则返回一个数组，其中存放了与他找到的匹配文本有关的信息说明:返回数组的第一个元素存放的是匹配文本，其余元素存放与正则表达式的子表达式（分组）匹配的文本 index声明匹配文本的起始字符在字符串的位置 input声明对stringObject的引用 全局调用match()方法将执行全局检索，找到字符串中的所有匹配字符串返回值：如果没有任何匹配的文本，返回null,如果找到了一个或者多个匹配子串，则返回一个数组说明：返回的数组中存放的是字符串中所有的匹配子串，而且也没有index属性或者input属性 String.prototype.split(reg)作用：把字符串分割为字符数组例如：&#39;a1b2c3d4&#39;.split(/\d/g)结果为[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] String.prototype.replace(str,replaceStr)例如：&#39;a1b&#39;.replace(&#39;1&#39;,2)结果为&#39;a2b&#39;例如：&#39;a1b1c1&#39;.replace(&#39;1&#39;,2)结果为&#39;a2b1c1&#39; String.prototype.replace(reg,replaceStr)例如：&#39;a1b&#39;.replace(/1/g,2)结果为&#39;a2b2c2&#39; String.prototype.replace(reg,function)function参数含义（function会在每次替换的时候调用，有4个参数）： 匹配字符串 正则表达式分组内容，没有分组则没有该参数（有多个分组择优多个参数） 匹配项在字符中的index 原字符串 例如：’a1b2c3d4’ =&gt; ‘a2b3c4d5’&#39;a1b2c3d4&#39;.replace(/\d/g,function(match,index,origin){retrun parseInt(match)+1;})结果为&#39;a2b3c4d5&#39;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记]]></title>
    <url>%2F2018%2F02%2F03%2FJavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JavaScript学习笔记什么是JavaScript?JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 完整的JavaScript由ECMAScript(语法)、Brower Object(DOM、BOM)（特性）组成的。 JavaScript语法注释//单行注释 /**/多行注释 语法ECMAScript中的一切（变量、函数名和操作符）都区分大小写。 标识符： 变量、函数、属性的名字或者函数的参数。 标识符的命名规则： 由字母、数字、下划线（ _ ）或美元符（$）组成 不能以数字开头 不能使用关键字、保留字作为标识符。 变量ECMAScript中的变量是松散类型。换句话说，每个变量仅仅是一个用于保存值的占位符而已。 松散类型：可以用来保存任何类型的数据 变量声明：变量声明要使用var操作符 语法：var 变量名 变量赋值： 声明的同时赋值： var 变量名 = 值 先声明后赋值： 变量名 = 值 说明：省略var声明的变量是全局变量 数据类型 简单数据类型：Undefined、Null、Boolean、Number(NaN是一个特殊的数值)、String 复杂数据类型：Object ES6新增了symbol数据类型 typeof功能： 检测变量类型 语法： typeof&nbsp;变量或typeof(变量) 返回值类型：string类型，有可能是：string、number、boolean、undefined、object、function。//前四个是值类型，后两个是引用类型 Number类型 Number: 表示整数和浮点数 NaN: 即非数值（Not&nbsp;a&nbsp;Number）是一个特殊的数值 说明： 任何涉及NaN的操作（例如NaN/10）都会返回NaN NaN与任何值都不相等，包括NaN本身 typeof(NaN类型的值)结果为number isNaN(n)：检测n是否为“非数值”，返回值为boolean类型，参数n可以是任意类型。 说明：isNaN对接受的值，先尝试转换为数值，再检测是否为非数值。比如：var&nbsp;age=”18”,Number.isNaN(age)返回值为false; 数值转换:有3个函数可以把非数值转换为数值： Number() parseInt() ParseFloat() 说明： Number()可以用于认可数据类型。 parseInt()和parseFloat（）则专门用于把字符串转换为数值。 提取的字符串必须以数字开头，如果以非数字开头，则类型为NaN。 String类型String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由双引号（””）或单引号（’’）表示 数值转换： 将其他类型转换为字符串有两种方法： toString() 语法：str.toString;&nbsp;&nbsp;功能：将str转换为字符串&nbsp;&nbsp;返回值：str的一个副本 参数：str是要转换的类型，可以是数值、布尔型、对象和字符串。 String() 说明：在不知道要转换的值是不是Null或者undefined的情况下，还可以使用String()函数，它能够将任何类型的值转换为字符串。 Boolean类型用于表示真假的类型，即true表示真，false表示假 数值转换： Boolean() 注意： 除0之外的所有数字，转换为布尔型都为true 除””之外的所有字符，转换为布尔型都为true(“”是空，空格也为true) null 和 undefined转换为布尔型为false 操作符 算数操作符（+、-、*、/、% 、a++ 、++a、a--、--a） 运算时会做隐士数据类型转换 逻辑操作符 &amp;&amp;、||、! &amp;&amp;(与):在有一个操作数不是布尔值的情况，逻辑与操作就不一定返回布尔值，此时他遵循以下规则： 如果操作数隐士类型转换后都为true,则返回最后一个操作数。例如：80&amp;&amp;55返回结果为55(80隐士类型转换为true). 如果操作数隐士类型转换后不都为true,则返回第一个为false的值。例如：0&amp;55返回结果为0(0隐士转换为false). 只要有一个操作数是null，则返回null 只要有一个操作数是NaN，则返回NaN 只要有一个操作数是undefined，则返回undefined ||(或)：在有一个操作数不是布尔值的情况，逻辑与操作就不一定返回布尔值，此时他遵循以下规则： 如果操作数隐士类型转换后不都为false,返回第一个为true操作数。例如：80&amp;&amp;55返回结果为80(80隐士类型转换为true). 如果操作数隐士类型转换后都为false,则返回最后一个操作数。例如：0&amp;55返回结果为55(0隐士转换为false). 如果两个操作数都是null，则返回null 如果两个操作数都是NaN，则返回NaN 如果两个操作数都是undefined，则返回undefined !(非)： 无论操作数是什么数据类型，逻辑非都会返回一个布尔值。 !!同时使用两个逻辑非操作符时： 第一个逻辑非操作会基于无论什么操作数返回一个布尔值 第二个逻辑非则对该布尔值求反 赋值操作符 简单赋值：= 复合赋值：+=、-=、*=、/=、%= 比较操作符 &gt;、&lt;、&gt;=、&lt;=、==、===、!=、!==返回值为boolean类型 三元操作符 语法：条件?执行代码1:执行代码2 说明：可替代简单if语句，如果条件成立，执行代码1，否则执行代码2 JavaScript条件语句分支语句if语句 switch语句 循环语句for循环 语法：for(语句1;语句2;语句3){被执行的代码块} 语句1：在循环(代码块)开始前执行 语句2：定义循环（代码块）的条件 语句3：在循环(代码块)已被执行之后执行 while循环 语法：while(条件){需要执行的代码块} do-while语句 语法：do{需要执行的代码}while(条件) 说明：这种语法的循环只是要被执行一次。 continue:结束本次循环，继续开始下一次。 break:退出整个循环体。 JavaScript内置对象ECMAScript中的Array创建数组 创建数组的基本方式有两种： 使用Array构造函数语法：new Array() 小括号()说明： 预先知道数组要保存的项目的数量 向Array构造函数中传递数组应包含的项 使用数组字面量表示法：由一对包含数组项的方括号[]表示，多个数组项之间用逗号隔开。 数组长度 语法:array.length功能：获取数组array的长度 返回值：number 说明：通过设置length可以从数组的末尾移除项或者向数组中添加新项 数组的栈方法： push() 语法：arrayObject.push(newele1,newele2,...) 功能：把它的参数顺序添加到arrayObject的尾部。 返回值：把指定值添加到数组后的新长度。 unshift()语法：arrayObject.unshift(newele1,newele2,...) 功能：把它的参数顺序添加到arrayObject的开头。 返回值：把指定值添加到数组后的新长度。 pop() 语法：arrayObject.pop() 功能：删除arrayObject的最后一个元素。 返回值：被删除的那个元素 shift() 语法：arrayObject.pop() 功能：删除arrayObject的第一个元素。 返回值：被删除的那个元素 数组的转换方法： join() 语法：arrayObject.join(separator) 说明：separator指访问时用什么分割符。没有参数时，默认用逗号连接起来 功能:用于把数组中所有元素放入一个字符串。 返回值：字符串 数组重排序： reverse（） 语法：arrayObject.reverse() 功能：用于颠倒数组中元素的顺序。 返回值：排完序以后的数组。 sort() 语法：arrayObject.sort(sortby) 功能：用于对数组中元素进行排序。 返回值：排完序以后的数组。 说明： 即使数组中的每一项都说数值，sort()方法比较的也是字符串。 sort()方法可以接受一个比较函数作为参数。 例如：数字降序。arrayObject.sort(function(a,b){return b-a}) 数组连接： concat() 语法：arrayObject.concat(arrayX,arrayX,….) 功能：用于连接两个或者多个数组。 返回值：数组。 截取数组中的元素： 语法：arrayObject.slice(start,end) 功能：从已有的数组中截取从start和end（不包含该元素）的元素，即截取从start到end-1的元素 参数： start(必须)规定从何处开始选取，如果是负数，从数组尾部开始算起。 end(可选)规定从何处结束选取，是数组片段结束处的下标。 说明： 如果没有指定end，切分的数组包含从start到数组结束的所有元素。 如slice()方法吃参数中有一个负数，则用数组长度加上该数来确定相应的位置。 返回值：数组 其他方法：splice() 删除元素语法：arrayObject.splice(index,count) 功能：删除从index处开始的零个或者多个元素。 返回值:含有被删除的元素的数组。 说明： count是要删除的项目数量，如果设置为0，则不会删除项目。如果不设置，则删除从index开始的所有值。 插入元素语法：arrayObject.splice(index,0，item1,...,itemX) 功能：在指定位置插入值 参数： index：起始位置 0：要删除的项数 item1,..,itemX:要插入的项 返回值：空数组。 替换元素语法：arrayObject.splice(index,count，item1,...,itemX) 功能：在指定位置插入值,且同时删除任意数量的项 参数： index：起始位置 count：要删除的项数 item1,..,itemX:要插入的项 返回值：从原始数组中删除的项（如果没有删除任何项，则返回空数组）。 关于位置的两个方法： indexOf() 语法：arrayObject.indexOf(searchvalue,startIndex) 功能：从数组的开头（位置0）开始向后查找 参数： searchvalue:必选，要查找的项 startIndex：可选，起始位置的索引。默认为0。 返回值：number,查找项在数组中的索引值，没有找到的情况下返回-1。 lastIndexOf() 语法：arrayObject.lastIndexOf(searchvalue,startIndex) 功能：从数组的末尾开始向前查找 参数： searchvalue:必选，要查找的项 startIndex：可选，起始位置的索引。如没有该参数，则从数组末尾开始向前查找 返回值：number,查找项在数组中的索引值，没有找到的情况下返回-1。 注：查找的项跟数组中的项比较时，会使用全等操作，即值和数据类型都必须相等 String字符串常用的方法： charAt() 语法：stringObect.charAt(index) 功能：返回stringObject中的index位置的字符。 说明：ES5中可使用”方括号加字符索引”来访问字符串中特定的字符，但IE7及更早的浏览器会返回undefined。 charCodeAt 语法：stringObect.charCodeAt(index) 功能：返回stringObject中的index位置字符的字符编码。 indexOf() 语法：stringObjec.indexOf(&quot;o&quot;) 功能：从一个字符串中由开头向后搜索给定的子字符串，返回子字符串的位置。 返回值：数值。 说明：如果没有找到该字符串，则返回-1。 lastIndexOf 语法：stringObjec.lastIndexOf(&quot;o&quot;) 功能：从一个字符串中由末尾向前搜索给定的子字符串，返回子字符串的位置。 返回值：数值。 说明：如果没有找到该字符串，则返回-1。 字符串对象的截取方法: slice() 语法：stringObject.slice(start,end) 功能：截取字符串。 参数说明： start:必需，指定子字符串的开始位置。 end:可选，表示子字符串到哪里结束，end本身不在截取的范围之内，省略时截取至字符串的末尾。 如slice()方法吃参数中有一个负数，则用数组长度加上该数来确定相应的位置。 substring() 说明：语法及功能同slice()完全一样。 区别在于： 当参数为负数时，自动将参数转换为0。 substring()会将较小的数作为开始位置，把较大的数作为结束位置。 substr() 语法：stringObject.substr(start,len) 功能：截取字符串。 参数说明： start:必需，指定子字符串的开始位置。 len:可选，表示截取的字符总数，省略时截取至字符串的末尾。 当start为负数时，会将传入的负数与字符串的长度相加。 当len为负数时，返回空字符串。 字符串分割为数组： split() 语法：stringObject.split(separator) 功能：把一个字符串分割成字符串数组。 返回值：Array。 说明：separator:必需，分隔符。 替换字符串的一些字符: replace() 语法：stringObject.replace(regexp/substr,replacement) 功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 返回值：String。 说明：regexp:必需，规定子字符串或要替换的模式的RegExp对象。 replacement:必需。 一个字符串值。 字符串转换大小写： toUpperCase() 语法：stringObject.toUpperCase() 功能：把字符串转换为大写。 toLowerCase() 语法：stringObject.toLowerCase() 功能：把字符串转换为小写。 MathDateDOM事件什么是事件事件就是文档或浏览器窗口中发生的一些特定的交互瞬间。 HTML事件概念：直接在HTML元素标签内添加事件，执行脚本。 语法：&lt;tag 事件 = &quot;执行脚本&quot;&gt;&lt;/tag&gt;。 功能：在HTML元素上绑定事件。 说明：执行脚本可以是一个函数的调用。 关于this的指向：在时间触发的函数中，this是对该DOM对象的引用。 DOM0级事件执行事件的步骤： 通过DOM获取HTML元素 （获取的HTML).事件=执行脚本。 语法：ele.事件=执行脚本 功能：在DOM对象上绑定事件 说明：执行脚本可以是一个匿名函数，也可以是一个函数的调用。 在调用自定义函数时，函数后面不要加括号。如加了括号，函数可能会自动执行，而不是被触发执行 例如： 1234btn.onclick= clickBtn function clickBtn()&#123; alert(&quot;我是按钮&quot;) &#125; 注：不建议使用HTML事件，原因如下： 多元素绑定相同事件时，效率低。 不建议在HTML元素中写JavaScript代码。 事件类型鼠标事件： onload:页面加载时触发(window.onload) onclick:鼠标点击时触发 onmouseover:鼠标滑过时触发 onmouseout:鼠标离开时触发 onfoucs:获得焦点时触发 onblur：失去焦点时触发 onchange:域的内容改变时触发(一般作用于select或checkbox或radio) onsubmit: 表单中的确认按钮被点击时发生(onsubmit事件不是加在按钮上，而是表单上) onmousedown: 鼠标按钮在元素上按下时触发 onmousemove: 在鼠标指针移动时触发 onmouseup: 在元素上松开鼠标按钮时触发 onresize: 当调整浏览器窗口的大小时触发 onscroll：拖动滚动条滚动时触发 BOM事件概念BOM（brower&nbsp;object&nbsp;model）浏览器对象模型 BOM对象BOM对包括： window对象 window是浏览器的一个实例，在浏览器中，window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象（全局对象）。 var age=15 等价于window.age=15 所有的全局变量和全局方法都被归在window对象上。 window对象的方法： alert方法： 语法：window.alert（&quot;content&quot;） 功能： 显示带有一段消息和一个确认按钮的警告框 confirm方法：语法：window.confirm&quot;message&quot;） 功能： 显示带有指定消息和OK及取消按钮的对话框 prompt方法： 语法：window.prompt(&quot;text,defaultText&quot;) 参数说明： text:要在对话框中显示的纯文本（而不是HTML格式的文本） defaultText:默认的输入文本 返回值：如果用户单机提示框的取消按钮，则返回null;如果用户单击确认按钮，则返回输入字段当前显示的文本。 说明：如果文本内容太长，需要换行，使用/n换行 open方法 语法:window.open(pageURL,name,parameters) 功能：打开一个新的浏览器窗口或查找一个已命名的窗口 参数说明： pageURL:子窗口路径 name: 子窗口句柄（name声明了新窗口的名称，方便后期通过name对子窗口进行引用） parameters:窗口参数（各参数用逗号分隔） close方法 语法:window.close() 功能：关闭浏览器窗口 定时器方法： 超时调用 语法：setTimeout(code,millisec) 功能：在指定的毫秒数后调用函数或计算表达式 参数说明： code:要调用的函数或要执行的JavaScript代码串 millisec:在执行代码前需要等待的毫秒数 注：setTimeout方法返回一个ID值，通过它取消超时调用 说明：setTimeout()只执行code一次。如果要多次调用，可以让code自身在此调用setTimeout(). 清除超时调用 语法：clearTimeout(id_of_settimeout) 功能：取消由setTimeout（）方法设置的timeout 参数说明：id_of_settimeout：由setTimeout()返回的ID值，该值标识要取消的延迟执行代码块。 间歇调用 语法：setInterval(code,millisec) 功能：每隔知道的时间执行一次代码 参数说明： code:要调用的函数或要执行的JavaScript代码串 millisec:周期性执行或调用code之间的时间间隔，以毫秒计 注：setInterval方法返回一个ID值，通过它取消间歇调用 清除间歇调用 语法：clearInterval(id_of_setInterval) 功能：取消由setInterval()方法设置的interval 参数说明： id_of_setInterval：由setInterval()返回的ID值，该值标识要取消的间歇执行代码块 注：setInterval方法返回一个ID值，通过它取消间歇调用 navigator对象 常用属性： userAgent属性 语法：navigator.userAgent 功能：用来失败浏览器名称、版本、引擎以及操作系统等信息的内容。 screen对象 screen对象包含有关客户端显示屏幕的信息 常用属性： availWidth属性 语法：screen.availWidth 功能：返回可用的屏幕宽度 availHeight属性 语法：screen.availHeight 功能：返回可用的屏幕高度 history对象 history对象保存了用户在浏览器镇南关访问页面的历史记录。是window对象的属性。 常用方法： back()方法 语法：history.back() 功能：回到历史记录的上一步。 说明：相当于使用了histoyr.go(-1)。 forward()方法 语法：history.forward() 功能：回到历史记录的下一步。 说明：相当于使用了histoyr.go(1)。 go()方法 语法：history.go(-n) 功能：回到历史记录的前n步。 语法：history.go(n) 功能：回到历史记录的后n步。 location对象 location对象提供了与当前窗口加载的文档有关的信息，还提供了一些导航功能，它既是window对象的属性，也是document对象的属性。 常用属性： href属性 语法：location.href或location.href=&#39;URL&#39; 功能：返回当前加载页面的完整URL或者跳转到设定URL（会在历史记录中生存记录） 说明：location.href与window.location.href等价 hash属性 语法：location.hash 功能：返回URL中的hash（#号后跟零或多个字符），如果不包含则返回空字符串。 host属性 语法：location.host 功能：返回服务器名称和端口号（如果有） hostname属性 语法：location.hostname 功能：返回不带端口号的服务器名称。 pathname属性 语法：location.pathname 功能：返回URL中的目录和（或）文件名。 port属性 语法：location.port 功能：返回URL中指定的端口号，如果没有，返回空字符串。 protocol属性 语法：location.protocol 功能：返回页面使用的协议。 search属性 语法：location.search 功能：返回URL的查询字符串，这个字符串以?开头。 常用方法： replace()方法 语法：location.replace(url) 功能：重新定向URL。 说明：使用location.replace()不会再历史记录中生成新纪录。 reload()方法： 语法：location.reload() 功能：重新加载当前显示的页面。 说明： location.reload()有可能从缓存中加载 location.reload(true)从服务器重新加载 document对象 event对象]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML学习笔记]]></title>
    <url>%2F2018%2F02%2F03%2FHTML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[HTML学习笔记HTML概念HTML（Hypertext Markup Language）即超文本标记语言。是标准通用标记语言下的一个应用，也是一种规范，一种标准，它通过标记符号来标记要显示的网页中的各个部分。 HTML特点 HTML不需要编译，直接由浏览器执行 HTML是一个文本文件 HTML 文件必须使用html或者htm为文件后缀名 HTML对大小写不敏感。HTML和html一样HTML基础语法 HTML 基本结构 1234567891011&lt;!DOCTYPE html&gt; ——————声明文档类型&lt;html&gt;&lt;head&gt; 网页头部信息 &lt;title&gt;标题&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 网页主体内容&lt;/body&gt;&lt;/html&gt;&lt;head&gt;&lt;/head&gt;标签内的所有内容不会再网页中显示 HTML标签 成对出现，开始标签和结束标签，结束标签比开始标签多了一个/ 单标签：没有结束标签。例如 标题标签:&lt;h1&gt;&lt;/h1&gt;~&lt;h6&gt;&lt;/h6&gt; 段落标签：&lt;p&gt;&lt;/p&gt; 换行标签：&lt;br/&gt; 水平线标签&lt;hr/&gt; 文字斜体：&lt;i&gt;&lt;/i&gt;、&lt;em&gt;&lt;/em&gt; 文字加粗：&lt;b&gt;&lt;/b&gt;、&lt;strong&gt;&lt;/strong&gt; 下标：&lt;sub&gt;&lt;/sub&gt; 上标：&lt;sup&gt;&lt;/sup&gt; 插入内容（下划线）：&lt;ins&gt;&lt;/ins&gt;删除内容：&lt;del&gt;&lt;/del&gt; 特殊符号: 比如&amp;lt; &lt; 无序列表：&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表：&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 定义列表：&lt;dl&gt;&lt;dt&gt;定义列表项&lt;/dt&gt;&lt;dd&gt;列表项描述&lt;/dd&gt;&lt;dd&gt;列表项描述&lt;/dd&gt;&lt;/dl&gt; 锚链接（同一页面）：&lt;a href=&quot;#锚名&quot;&gt;目录名&lt;/a&gt; 锚链接（不同页面页面）：&lt;a href=&quot;网页名称#锚名&quot;&gt;目录名&lt;/a&gt; 电子邮箱链接：&lt;a href=&quot;mailto:邮件地址&quot;&gt;名称&lt;/a&gt; HTML元素 HTML属性 注释html使用&lt;!-- --&gt;进行注释]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6语法]]></title>
    <url>%2F2018%2F02%2F03%2FES6%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ES6语法说明：ES6强制开启严格模式。严格模式变量未声明不能引用报引用错误。 变量声明方式 块作用域：任何一对花括号（｛｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 let let声明的变量是在块作用域有效。说明：let不能重复声明变量 const const声明的常量是不能修改的，也是在块作用域有效。注：const声明的时候必须赋值。console声明对象，是引用属性的，指针不会改变。 解构赋值ES6变量的解构赋值本质上是“模式匹配”,只要等号两边的模式相同，左边的变量就会被赋予匹配的右边的值，如果匹配不成功变量的值就等于undefined如下面的例子： { let a,b,rest; [a,b]=[1,2]; console.log(a,b); } // 1,2 { let a,b,rest; [a,b,...rest]=[1,2,3,4,5,6]; console.log(a,b,rest); } //1, 2, [3, 4, 5, 6] { let a,b; ({a,b}={a:1,b:2}) console.log(a,b); } // 1,2 { let a,b,c,rest; [a,b,c=3]=[1,2]; console.log(a,b,c); } //1,2,3 { let a=1; let b=2; [a,b]=[b,a]; console.log(a,b); } // 2,1 { function f(){ return [1,2] } let a,b; [a,b]=f(); console.log(a,b); } // 1,2 { function f(){ return [1,2,3,4,5] } let a,b,c; [a,,,b]=f(); console.log(a,b); } // 1,4 { function f(){ return [1,2,3,4,5] } let a,b,c; [a,,...b]=f(); console.log(a,b); } // 1,[3,4,5] { let o={p:42,q:true}; let {p,q}=o; console.log(p,q); } // 42,true { let {a=10,b=5}={a:3}; console.log(a,b); } //3 ,5 { let metaData={ title:&#39;abc&#39;, test:[{ title:&#39;test&#39;, desc:&#39;description&#39; }] } let {title:esTitle,test:[{title:cnTitle}]}=metaData; console.log(esTitle,cnTitle); } // abc,test 正则扩展JavaScript正则扩展详细讲解了正则表达式及ES6新增内容 字符串扩展字符串新增特性： Unicode表示法主要处理大于0xFFFF的字符例如：console.log(&#39;a&#39;,\u0061);//a,aconsole.log(&#39;s&#39;,\u20BB7);//s ₻7因为大于0xFFFF，所以无法正常显示。ES6中，可以用{}把Unicode编码包起来表示一个例如：console.log(&#39;s&#39;,\u{20BB7});//s 𠮷 遍历接口在ES6中遍历操作特质for….of循环。在ES6中，一个对象只要部署了next方法，就被视为是具有了iterator接口，就可以用for…of循环遍历它的值。例如：{&nbsp;&nbsp;let str=&#39;\u{20bb7}abc&#39;;&nbsp;&nbsp;for(let i=0;i&lt;str.length;i++){&nbsp;&nbsp;&nbsp;&nbsp;console.log(&#39;es5&#39;,str[i]);//不能正确识别{20bb7}&nbsp;&nbsp;}&nbsp;&nbsp;for(let code of str){&nbsp;&nbsp;&nbsp;&nbsp;console.log(&#39;es6&#39;,code);//识别{20bb7}为𠮷&nbsp;&nbsp;}} 模板字符串ES5中要把多个字符串连接起来，可以用+号连接：如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，会自动替换字符串中的变量。例如：let name=&quot;list&quot;;let info=&quot;hello world&quot;;let m=i am ${name},${info};console.log(m);//结果为i am list,hello world 标签模板 新增方法 str.codePointAt():能够正确处理4个字节储存的字符，返回指定索引出一个字符的码点。codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。例如：let s=&#39;𠮷&#39;;console.log(&#39;length&#39;,s.length);//length,2console.log(&#39;0&#39;,s.charAt(0));//0,�console.log(&#39;1&#39;,s.charAt(1));//1,�console.log(&#39;at0&#39;,s.charCodeAt(0));//at0,55362console.log(&#39;at1&#39;,s.charCodeAt(1));//at1,57271上面两个方法不能正确处理四个字节（大于0xFFFF）的字符，而ES6中新增的codePointAt()则能很好的处理let s1=&#39;𠮷a&#39;;console.log(&#39;length&#39;,s1.length);//length，3console.log(&#39;code0&#39;,s1.codePointAt(0));//code0，134071console.log(&#39;code0&#39;,s1.codePointAt(0).toString(16));//code0，20bb7console.log(&#39;code1&#39;,s1.codePointAt(1));//code1，57271console.log(&#39;code2&#39;,s1.codePointAt(2));//code2，97 str.fromCodePoint()：通过Unicode码值转换对应的字符与es5的String.fromChartCode()相比，他可以识别四个字节 字符（Unicode编号大于0xFFFF）。例如：console.log(String.fromCharCode(&quot;0x20bb7&quot;));//ஷconsole.log(String.fromCodePoint(&quot;0x20bb7&quot;));//𠮷 str.includes():返回一个布尔值，表示某个字符串是否包含给定的字符。例如:let str = &quot;string&quot;console.log(str.includes(&quot;r&quot;))//结果为true str.startsWith():给定文本出现在字符串开头时返回 true，否则返回 false 。例如:let str = &quot;string&quot;console.log(str.startsWith(&quot;str&quot;))//结果为true str.endsWith():给定文本出现在字符串末尾时返回 true，否则返回 false 。例如:let str = &quot;string&quot;console.log(str.endsWith(&quot;g&quot;))//结果为true str.repeat():字符串复制例如:let str = &quot;ab&quot;console.log(str.repeat(3))//结果为ababab Sring.raw：往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。例如：console.log(String.rawHi\n${1+2}//Hi\n3);console.log(Hi\n${1+2}//Hi(换行)3); str.padStart():向前补白例如：console.log(&#39;1&#39;.padStart(2,&#39;0&#39;));//结果为01注：第一个参数2为输出字符串的长度，第二个为补白的字符串 str.padEnd():向后补白例如：console.log(&#39;1&#39;.padEnd(2,&#39;0&#39;));//结果为10注：第一个参数2为输出字符串的长度，第二个为补白的字符串 多行字符串：由于多行字符串用\n写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` 多行内容` 表示 数值扩展 新增方法 Number.isFinite():判断一个数是否是有效数字例如：console.log(&#39;15&#39;,Number.isFinite(15));//15,trueconsole.log(&#39;1/0&#39;,Number.isFinite(&#39;true&#39;/0)); //1/0,false Number.isInteger():判断一个数是否为整数。注：参数必须是一个数，否则为false。参数如果是数，会先看能否转换为整数，再判断例如：console.log(&#39;25&#39;,Number.isInteger(25));//25，trueconsole.log(&#39;25.0&#39;,Number.isInteger(25.0)); //25.0,trueconsole.log(&#39;25.1&#39;,Number.isInteger(25.1)); //25.1,falseconsole.log(&#39;25&#39;,Number.isInteger(&#39;25&#39;)); //25,false Number.isSafeInteger():判断一个数是否在安全区间（-2的53次方到2的53此方，不包含端点）。例如：console.log(Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);//取安全区间的最大值和最小值console.log(&#39;10&#39;,Number.isSafeInteger(10)); //10 trueconsole.log(&#39;a&#39;,Number.isSafeInteger(&#39;a&#39;)); //a false Math.trunc():去一个带小数的整数部分例如：console.log(4.1,Math.trunc(4.1));//4.1 4console.log(4.9,Math.trunc(4.9));//4.9 4 Math.sign():判断一个数是整数负数还是0返回值：正数返回1，负数返回-1，0返回0，其余返回NAN。例如：console.log(&#39;-5&#39;,Math.sign(-5));//-5 -1console.log(&#39;0&#39;,Math.sign(0));//0 0console.log(&#39;5&#39;,Math.sign(5));//5 1console.log(&#39;50&#39;,Math.sign(&#39;50&#39;));//50 1console.log(&#39;foo&#39;,Math.sign(&#39;foo&#39;));//foo NaN Math.cbrt():求一个数的立方根例如：console.log(&#39;-1&#39;,Math.cbrt(-1));console.log(&#39;8&#39;,Math.cbrt(8)); 方法调整 Number.isNaN():判断一个数是否为非数字。注：与ES5的区别是使用Number对象调用，而不是直接调用 数组扩展 Array.of():方法用于将一组值，转换为数组。 Array.from()Array.from方法用于将两类对象转为真正的数组常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 Array.fill():fill方法使用给定值，填充一个数组。 用于空数组的初始化非常方便。console.log(&#39;fill-7&#39;,[1,&#39;a&#39;,undefined].fill(7));//[7, 7, 7]console.log(&#39;fill,pos&#39;,[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;].fill(7,1,2));//[&quot;a&quot;, 7, &quot;c&quot;]（第一个参数要替换的元素，第二个参数替换的开始位置，第二个参数替换的结束位置（不包含该位置）） copyWithin():数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。例如：console.log([1,2,3,4,5].copyWithin(0,2,4));// [3, 4, 3, 4, 5]第一个参数为开始替换的位置，第二个参数为要替换的元素开始的位置，第三个参数要替换的元素截止的位置（不包括改位置元素） Array.keys():返回数组的下标 Array.values():返回数组的值注意：兼容性问题，有的浏览器不支持 Array.entries():返回数组的下标和对应的值 Array.includes():返回一个布尔值，表示某个数组是否包含给定的值，该方法属于ES7，但Babel转码器已经支持。 Array.find():用于找出第一个符合条件的数组成员。返回符合条件的成员。NaN也能判断console.log(&#39;number&#39;,[1,2,NaN].includes(1));//trueconsole.log(&#39;number&#39;,[1,2,NaN].includes(NaN));//true例如：console.log([1,2,3,4,5,6].find(function(item){return item&gt;3}));//4 Array.findIndex():用于找出第一个符合条件的数组成员。返回符合条件的成员&lt;的下标例如：console.log([1,2,3,4,5,6].findIndex(function(item){return item&gt;3}));//3 函数扩展 参数默认值：可以给参数设置一个默认的值，如果没有传入该参数，则为默认值，如果传入了，使用传入的参数值。注意：默认值后面不能再出现没有默认值的参数。 rest参数 扩展运算符 箭头函数 this绑定 尾调用 对象扩展 简洁表示法 属性表达式 扩展运算符 Object新增方法 Symbol用法 概念 作用 set和map数据结构set-map和对象的比较Proxy和reflect Proxy和reflect概念 用法 类和对象 基本语法 类的继承 静态方法 静态属性 getter setter PromiseIteratorGenertorDecorators模块化]]></content>
      <tags>
        <tag>ES6语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue+node+mongodb商城系统]]></title>
    <url>%2F2018%2F02%2F03%2Fvue%2Bnode%2BmongoDB%E5%95%86%E5%9F%8E%2F</url>
    <content type="text"><![CDATA[vue+node+mongodb商城系统Vue和React对比Vue和React都使用了Virtual DOM Vue： 模板和渲染函数的弹性选择 简单的语法及项目创建 更快的渲染速度和更小的体积 React： 更适用于大型应用和更好的可测试性 同时适用Web端和原生App 更大的生态圈带来的更多支持和工具 Vue和React相同点： 利用虚拟DOM实现快速渲染 轻量级 响应式组建 服务器端渲染 易于集成路由工具，打包工具及状态管理工具 优秀的支持和社区 Vue概况以及核心思想 Vue本身并不是一个框架 Vue结合周边生态构成一个灵活的、渐进式框架 核心思想： 数据驱动 组件化 项目所使用的技术 前端使用Vue全家桶以及ES6 前端主要采用Vue.js-MVVM渐进式框架 视图层:商品列表、购物车、地址列表、商品结算、订单成功 插件：公共组件、Vue-Router(路由)、Axios、VueS、Util、依赖（第三方插件） 工具支持：vue-cli(生成项目模板)、webpack(构建工具) 后端使用Express框架 数据库使用MongoDB 1.安装和搭建NodeJS和npm环境2.vue环境搭建及vue-cli使用vue多页面应用文件引入： 官网拷贝 &lt;script src=&quot;https://unpkg.com/vue/dist/vie.js&quot;&gt;&lt;/script&gt; npm安装 npm install vue --save &lt;script src=&quot;node_modules/vue/dist/vue.min.js&quot;&gt;&lt;/script&gt; vue-cli构建SPA(single page application)应用 npm install -g vue-cli（使用Vue命令之前必须安装，如安装过则不需安装） vue init webpack-simple demo或vue init webpack demo2 第二个命令后会出现一些要填写的选项: Project name(Demo):项目名称（不能有大写） Project description(A vue.js project):项目描述 Author:作者 Vue build?(Use arrow keys):选择打包方式，有两种方式（runtime和standalone），使用默认即可 Install vue-router? (Y/n):是否安装路由，一般都要安装 Use ESLint to lint your code? (Y/n):-是否启用eslint检测规则，这里个人建议选no，因为经常会各种代码报错，新手还是不安装好 Set up unit tests (Y/n):是否安装单元测试 Setup e2e tests with Nightwatch? (Y/n)：是否安装e2e测试 3.Vue配置介绍 bulid文件夹：打包的配置文件所在的文件夹 build.js:构建生产版本 check-version:检查版本 webpack.base.conf.js:打包的核心配置 webpack.prod.conf.js:生产包的配置 config文件夹: 打包的配置 index.js：开发的环境配置 src:项目源码 static:静态资源 .babelrc:ES6编译插件的配置 .gitignore:git忽略的地址 .editorconfig:编辑器的配置 .postcssrc：html添加前缀的配置 index.html:单页面的入口 package.json：定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 scripts:脚本命令 dependencies:项目的依赖库 devDependencies:开发依赖库(打包好之后就不需要了) engines：引擎 4.Vue基础语法 模板语法 Mustache语法： Html赋值：v-html=&quot;&quot; 绑定属性：v-bind:id=&quot;&quot; 使用表达式： 1&#123;&#123; ok?&quot;Yes&quot;:&quot;No&quot; &#125;&#125; 文本赋值：v-text=&quot;&quot; 指令：v-if=&quot;&quot; 过滤器：和v-bind:id=&quot;rawId|formatId&quot; Class和Style绑定 class绑定对象语法：v-bind:class=&quot;{active: isActive,&#39;text-danger&#39;:hasError}&quot; class绑定数组语法： 123456&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;data: &#123; activeClass: &apos;active&apos;, errorClass: &apos;text-danger&apos;&#125; style绑定对象语法：v-bind:style=&quot;{ color: activeColor, fontSize: fontSize + &#39;px&#39; vue事件处理器 v-on:click=&quot;greet&quot;或@click=&quot;greet&quot; vue组件 全局组件和局部组件 父子组件通讯-数据传递 Slot vue自定义组件中的data必须为函数，否则是多个组件公用一个data，一个值发生变化会影响所有组件 5.Vue-router路由简介路由：路由是根据不同的URL地址展示不同的内容或页面 前端路由：前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前通过服务器根据url的不同返回不同的页面实现的 什么时候使用前端路由？ 在单页面应用，大部分页面结构不变，只改变部分内容的使用 前端路由的优缺点： 优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户 缺点： 不利于SEO 使用浏览器的前进，后退会重新发送请求，没有合理利用缓存 单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动条的位置 vue-router vue-router用来构建SPA &lt;router-link&gt;&lt;/router-link&gt;或者this.$router.push({path:&#39;&#39;}) 路由调整 &lt;vouter-view&gt;&lt;/router-view&gt; 路由渲染 动态路由匹配 动态路由举例： 模式：/user/:username 匹配路径：/user/evan $route.params:{username:&#39;evan&#39;} 模式：/user/:username/post/post_id 匹配路径：/user/evan $route.params:{username:&#39;evan&#39;,post_id:123} 地址后面跟#因为路由模式用的hash,可以在Router下的index.js添加mode:&#39;history&#39;改变原生的URL方式 嵌套路由 嵌套路由即为路由嵌套路由 在路由中定义子路由（router下的index.js） 12345678910111213141516171819routes: [ &#123; path: &apos;/goods&apos;, name: &apos;GoodsList&apos;, component: GoodsList, children:[ &#123; path: &apos;title&apos;,//子路径注：路径前面不能加/,否则变为一级路由 name: &apos;title&apos;, component: Title //组件 &#125;, &#123; path: &apos;image&apos;, //子路径 name: &apos;image&apos;, component: Image //组件 &#125; ] &#125; ] 在父路由页面添加： 12345 &lt;router-link to=&apos;/goods/title&apos;&gt;显示商品标题&lt;/router-link&gt; //路径必须自己定义到父路径，并不能只写子路径&lt;router-link to=&apos;/goods/img&apos;&gt;显示商品图片&lt;/router-link&gt;&lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; //组件渲染载体。&lt;/div&gt; 编程式路由 通过JS来实现页面的跳转 $route.push(&quot;name&quot;)通过名字跳转 $route.push({path:&quot;name&quot;})通过路径跳转 $route.push({path:&quot;name?a=123&quot;})或者$route.push({path:&quot;name&quot;，query:{a:123}})跳转的同时添加一些参数，获取参数用$route.query.a来获取 $route.go()相当于history.go(),vue-router是对history的封装 命名路由和命名视图 命名路由：给路由定义不同的名字，根据名字进行匹配 例如： 在路由中给组件命名： 123456789101112routes: [ &#123; path: &apos;/goods&apos;, name: &apos;GoodsList&apos;, component: GoodsList, &#125;, &#123; path: &apos;/cart/:cartId&apos;, name: &apos;cart&apos;, component: Cart &#125; ] 在页面中&lt;router-link v-bind:to=&#39;{name:&#39;cart&#39;,params:{cartId:&#39;123&#39;}}&#39;&gt;跳转到购物车页面&lt;/router-link&gt;//注：to得用V-bind绑定 命名视图：给不同的router-view定义名字，通过名字进行对应组件的渲染 6.Vue-Resource（异步插件）简介 使用方式 &lt;script src=&quot;https://cdn.jsdelivr.net/vue.resource/1.3.1/vue-resource.min.js&quot;&gt;&lt;/script&gt; npm install vue-resource --save &lt;script src=&quot;node_modules/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;script src = &quot;node_modules/vue-resource/dist/vue-resource.js&quot;&gt;&lt;/script&gt;//引用vue-resource插件前要先引用vue插件 vue-resource的请求API是按照REST风格设计的，它提供了7种请求API： get(url,[options]) head(url,[options]) delete(url,[options]) jsonp(url,[body],[options]) post(url,[body],[options]) put(url,[body],[options]) patch(url,[body],[options]) 7.了解AXIOS插件（异步请求插件） 使用方式 &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; npm install axios --save &lt;script src=&quot;./../node_modules/axios/dist/axios.js&quot;&gt;&lt;/script&gt; axios提供了8种请求API： axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.options(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) 8.商品列表基础组件拆分 Header组件 Footer组件 面包屑组件 组件：可以被其他页面复用的（通常放在component里面） 页面：只是自己使用的（存放在views里面） assets和static通常用来放静态资源，assets通常用来放组件的资源，static通常放页面资源等 组件中中必须有个根元素 组件中如果没用最好删掉，否则会在页面生成空的 要变换的内容可以使用插槽,如果有多个插槽，可以给插槽命名 模拟mock数据，加载商品列表信息 自己自定义模拟的JSON数据，来验证代码的有效性和合法性 自定义JSON文件，按照接口给的规范模拟数据 在webpack.dev.conf.js(老版本的dev-server.js)设置新版本，在const portfinder = require(&#39;portfinder&#39;)下面添加： 12345678910111213141516171819202122232425262728293031323334 //首先const express = require(&apos;express&apos;)const app = express()var appData = require(&apos;../data.json&apos;)var seller = appData.sellervar goods = appData.goodsvar ratings = appData.ratingsvar apiRoutes = express.Router()app.use(&apos;/api&apos;, apiRoutes) //URL必须有，否则找不到该路由//找到devServer,添加before(app) &#123; app.get(&apos;/api/seller&apos;, (req, res) =&gt; &#123; res.json(&#123; // 这里是你的json内容 errno: 0, data: seller &#125;) &#125;), app.get(&apos;/api/goods&apos;, (req, res) =&gt; &#123; res.json(&#123; // 这里是你的json内容 errno: 0, data: goods &#125;) &#125;), app.get(&apos;/api/ratings&apos;, (req, res) =&gt; &#123; res.json(&#123; // 这里是你的json内容 errno: 0, data: ratings &#125;) &#125;)&#125; 在页面请求配置的url即可得到返回的数据]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS学习笔记]]></title>
    <url>%2F2018%2F02%2F03%2Fcss%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CSS学习笔记什么是CSS？CSS 层叠样式表（Cascading Style Sheets） 用于定义HTML内容在浏览器内的显示样式 CSS学习HTML页面的三种布局方式： 标准流 浮动 定位 css基础语法css 规则有两部分构成：选择器，声明 css注释/注释内容/ css使用方法 行内样式（内联样式）：同时加载 例如：&lt;p Style=&quot;color: red;&quot;&gt;内容&lt;/p&gt; 内部样式表（嵌入样式）：同时加载 CSS样式&lt;style type=&quot;text/css&quot;&gt;样式&lt;/style&gt; 注：&lt;style&gt;&lt;/style&gt;要放在&lt;head&gt;标签之间 -内部样式表（导入式）：在读取完html文件之后加载 例如：123&lt;style type=&quot;text/css&quot;&gt; @import url(css的url地址)；或者@import&quot;css的url地址&quot; &lt;/style&gt; 外部样式表： 页面加载时，同时加载CSS样式 外部样式表，把CSS样式代码写在独立的一个文件中，名称：文件名.css 引入外部文件&lt;link href=&quot;XX.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; 注：&lt;link/&gt;标签要放在&lt;head&gt;标签之间 css选择器css选择器有以下类型： 标签选择器 以html标签作为选择器。 例如：h1{font-size: 30px;} 类选择器 为HTML标签添加class属性，通过类选择器来为具有此class属性的元素设置css样式例如：&lt;h1 class=&quot;classname&quot;&gt;内容&lt;/h1&gt; .classname{color:red;}还可以对不同类型元素的同一名称的类选择器设置不同的样式规则例如:12&lt;h1 class=&quot;red&quot;&gt;内容&lt;h1&gt; &lt;p class=&quot;red&quot;&gt;内容&lt;/p&gt;p.red&#123;font-size:50px;&#125; h1.red&#123;font-size:20px&#125; ID选择器 为HTML标签添加ID属性，通过ID选择器来为具有此ID属性的元素设置css样式&lt;p id=&quot;one&quot;&gt;内容&lt;/p&gt; #one{color:green;} 全局选择器 所有标签设置样式 例如：*{color: blue;} 群组选择器 集体统一设置样式 例如：p,h1,h2,h3{font-size:50px;} 后代选择器 使用后代选择器设置，之间用空格隔开例如：&lt;p&gt;&lt;em&gt;css&lt;/em&gt;层叠样式&lt;/p&gt; p em{font-size:40px;} 伪类 伪类选择器定义特殊状态下的样式，无法用标签、id、class及其他属性实现例如：链接伪类&lt;a href=&quot;&quot;&gt;&lt;/a&gt; a:link{color:blue;} --为访问的链接 a:visited{color:red;} --已访问的链接 a:hover{color:green;} --鼠标悬停状态 a:active{color:gray;} --激活的链接 链接伪类的顺序： :link&gt;:visited&gt;:hover&gt;:avtive 说明： a:hover必须置于a:link和a:visited之后，才有效 a:active必须置于a:hover之后才有效 伪类名称对大小写不敏感 css优先级行内样式&gt;&gt;内部样式&gt;&gt;外部样式 内部样式跟外部样式的优先级取决于接近元素的位置，越接近于元素，优先级越高 id选择器&gt;class选择器&gt;标签选择器 同一个元素引用多个class定义的样式，越接近于元素，优先级越高 后代选择其中，采用权值高的样式，权值相同，则采用就近原则 通过在样式中添加{!important}来调解优先级 css继承和层叠css继承：从父元素继承部分属性，当上级样式与元素本身样式冲突时，会忽略继承来的样式 css层叠： 可以定义多个样式 不冲突时，多个样式可以层叠为一个 冲突时，按不同样式规则优先级来应用样式 css命名规范 采用英文字母、数字以及”-“和_命名 以小写字母开头，不能以数字和”-“、_开头 命名形式：单字、连字符、下划线和驼峰 使用有意义的命名 css字体样式css中字体加粗用font-weight 设置字体样式： font-style 设置元素中文本为小型大写字母：font-variant css文本样式设置段落对齐方式：text-align只对块级的元素起作用 设置元素内容的垂直方式： vertical-align属性。 只对行内元素、单元格元素生效，对块级元素不生效。 多行元素垂直居中，将元素转换为单元格元素display:table-cell;并在其负累样式中添加display:table 设置元素中文本行高： line-height:长度值|百分比 设置字体属性： word-spacing设置元素内单词之间的间距(间距判断以空格为准） letter-spacing设置元素内字母之间的间距 text-transform设置元素内字母的大小写 text-decoration设置文本的装饰样式（下划线等等） css背景和列表背景样式： background-color(设置元素的背景颜色)background-color:颜色|transparent 说明： transparent是全透明黑色的（black）速记法，类似于rgba(0,0,0,0)这样的值。 颜色值（颜色名|RGB|十六进制） 背景去包括内容、内边距（padding）和边框，不包括外边距（margin）。边框颜色默认为文本颜色 background-image(把图像设置为背景) background-image:url(url地址)|none 说明： url地址可以是相对地址也可以是觉得地址 元素的背景占据了元素的觉得尺寸，包括内边距和边框，但不包括外边距 默认地，背景图元素位于元素的左上角，并在水平和垂直方向上重复 同时设置了背景图片和背景颜色，背景颜色会被覆盖 background-position(设置背景图像的起始位置,,针对整个网页的位置)background-position:百分比|值|top|right|bottom|left|center background-attachment(背景图像是否固定或者随着页面的其余部分滚动)background-attachment:scroll|fixed设置元素背景图片的显示方式 说明： 默认值，背景图片岁滚动条滚动 当页面其余部分滚动是，背景图片不会移动 background-repeat(设置背景图像是否重复及如何重复) background-repeat: repeat重复 background-repeat: no-repeat不重复 background-repeat: repeat-x水平重复 background-repeat: repeat-y垂直重复 background(简写属性，作用是将背景属性设置在一个声明中)background: [background-color] [background-image] ....例如：background: #000000 url() repeat 说明： 各值之间用空格分开，不分先后顺序 列表样式 list-style-type 设置列表项标志的类型list-style-type:关键字|none list-style-image 将图像设置为列表标志 list-style-type:url(图片地址)|none list-style-position 设置列表中列表项标志的位置 list-style-position:inside|outside 说明： inside:列表项目标记放置在文本以内，且环绕文本跟据标记对齐 outside: 默认值，列表项项目标记放置在文本以外，且环绕文本不根据标记对齐 list-style 简写属性。用于吧所有列表的属性设置于一个声明中 list-style:列表样式属性关键字 说明： 值之间用空格隔开 顺序不固定 list-style-image会覆盖list-style-type的设置 盒子模型概念 盒子模型用来“放”网页中的各种元素 盒子设计中内容，如文字、图片等元素，都可是盒子（DIV嵌套） 属性盒子在页面中所占的宽度由左边距（左外边距）+左边框+左填充（左内边距）+内容宽度+右填充+右边框+右边距组成。高度计算同上 宽度属性（内容，不含边距） 宽度：width:长度值|百分比|auto 最大宽度：max-width:长度值|百分比|auto 最小宽度：min-width:长度值|百分比|auto设置的宽度小于最小宽度是，显示最小宽度；大于最大宽度，显示最大宽度值；值在最大宽度和最小宽度之间，显示设置值 高度属性（内容，不含边距） 高度：height:长度值|百分比|auto 最大高度：max-height:长度值|百分比|auto 最小高度：min-height:长度值|百分比|auto 宽度和高度属性哪些可以设置 块级元素：&lt;p&gt;、&lt;div&gt;、&lt;h1&gt;~&lt;h6&gt;、&lt;ul&gt;、&lt;li&gt;、&lt;ol&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;dd&gt;等 替换元素：浏览器根据其标签的元素和属性来判断显示的具体内容&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;等 边框属性 边框宽度（border-width）设置元素边框宽度border-width:thin|medium|thick长度值 边框颜色（border-color）设置元素边框颜色border-color:颜色|transparent(透明色) 边框样式（border-style）设置边框样式border-style:值 border-style默认值为none，设置了border-style的值宽度和颜色才能显示出来 设置不同方向的边框属性：border-top：宽度|样式|颜色border-left：宽度|样式|颜色border-bottom：宽度|样式|颜色border-right：宽度|样式|颜色 内边距（padding）属性设置元素内容与边框之间的距离（内边距或填充），分四个方向（上右下左） padding-top:长度值|百分比 padding-right:长度值|百分比 padding-bottom:长度值|百分比 padding-left:长度值|百分比 说明：值不能为负值 内边距属性缩写： padding: 值1； //4个方向都为值1 padding: 值1 值2； //上下=值1，左右=值2 padding: 值1 值2 值3； //上=值1，左右= 值2，下=值3 padding: 值1 值2 值3 值4； //上=值1，右=值2，下=值3，左=值4 外边距（margin）属性设置元素内容与元素之间的距离（外边距或填充），分四个方向（上右下左） padding-top:长度值|百分比 padding-right:长度值|百分比 padding-bottom:长度值|百分比 padding-left:长度值|百分比 说明：值可以为负值 外边距属性缩写： margin: 值1； //4个方向都为值1 margin: 值1 值2； //上下=值1，左右=值2 margin: 值1 值2 值3； //上=值1，左右= 值2，下=值3 margin: 值1 值2 值3 值4； //上=值1，右=值2，下=值3，左=值4 注意： 默认情况下，相应HTML块级元素存在外边距，如：body、h1~h6、p等 声明margin属性，覆盖默认样式。如body,h1,p{margin:0;} margin值为auto,实现水平方向居中显示，由浏览器计算外边距 如果垂直方向相邻的两个元素都设置margin值，去值大的 HTML元素分类 块级元素，独占一行：&lt;p&gt;、&lt;div&gt;、&lt;h1&gt;~&lt;h6&gt;、&lt;ul&gt;、&lt;li&gt;、&lt;ol&gt;、&lt;dl&gt;、&lt;dt&gt;、&lt;dd&gt;等 行内元素（内联元素），一行显示：&lt;span&gt;、&lt;a&gt;、&lt;em&gt;等 display属性 inline : 元素将显示为内联元素，元素前后没有换行符 bLock : 元素将显示为块级元素，元素前后带有换行符 inline-block:行内块元素，元素呈现为inline，具有block特性 none:此元素不会被显示 注: 相应内联元素及使用display:inline设置成内联元素的width和height属性无效。水平方向margin-left/margin-right/padding-left/padding-right有效。垂直方向margin-top/margin-bottom/padding-top/padding-bottom无效 块级元素使用display:block设置成块级元素的width/height/margin/padding属性都生效 浮动（float）属性float中的四个参数： float:left //左浮动 float:right //右浮动 float:none //不浮动 float:inherit //继承浮动 浮动的副作用：给元素设置了浮动属性，元素可能脱离正常的标准流布局 解决副作用的方法： 手动给父元素添加高度 通过clear清除内部和外部浮动 给父元素添加overfloat属性并结合zoom:1使用 给父元素添加浮动 clear属性 clear:none clear:left //不允许左边有浮动对象 clear:right //不允许右边有浮动对象 clear:both //不允许有浮动对象 定位（position）属性意义 position属性决定了元素将如何定位 通过top、right、bottom、left实现位置 position中的可选参数 static //默认属性，元素按照标准流排布 relative //相对定位，正常按照标准流排布，但可通过top、right、bottom、left改变元素位置 absolute //绝对定位，元素脱离正常标准流排布，通过top、right、bottom、left改变元素位置 fixed //固定定位。通过top、right、bottom、left改变元素位置，不受制于父元素 inherit //继承父类元素的属性 z-index 可以设置元素的叠加顺序，但依赖定位属性 z-index大的元素会覆盖z-index小的元素 z-index为auto的元素不参与层级比较 z-index为负值，元素会被普通流中的元素覆盖 css页面布局经典的行布局 基础的行布局 行布局自适应 行布局自适应限制最大宽 行布局垂直水平剧中]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议之HTTP协议]]></title>
    <url>%2F2018%2F02%2F03%2FTCP%20IP%E5%8D%8F%E8%AE%AE%E4%B9%8BHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP/IP协议之HTTP协议简介HTTP全称是HyperText Transfer Protocal，即：超文本传输协议。超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。 从1990年开始就在WWW上广泛应用，是现今在WWW上应用最多的协议Http是应用层协议。HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。 HTTP协议的特点 支持B/S及C/S模式 简单快速：请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP工作原理一次HTTP操作称为一个事务，其工作整个过程如下： 地址解析如用客户端浏览器请求这个页面：http://localhost.com:8080/index.html从中分解出协议名、主机、端口、对象路径等部分，对于上面这个地址，解析得到结果如下：协议名：http主机名：localhost.com端口：8080对象路径：/index.html在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 封装HTTP请求数据包把以上部分结合本机自己的信息，封装成一个HTTP请求数据包。 封装成TCP包，建立TCP连接（TCP的三次握手）在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口。 客户机发送请求命令建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 服务器响应服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。 服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP协议之URLHTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息 URL,全称是Uniform&nbsp;Resource&nbsp;Locator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name从上面的URL可以看出，一个完整的URL包括以下几部分： 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&amp;ID=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。（原文：http://blog.csdn.net/ergouge/article/details/8185219 ） HTTP协议之Requesthttp请求由四部分组成，分别是：请求行、请求头部、空行、请求正文HTTP的请求方式包括如下几种： GET(请求获取Request-URI所标识的资源) POST(在Request-URI所标识的资源后附加新的数据) HEAD(请求获取由Request-URI所标识的资源的响应消息报头) PUT(请求服务器存储一个资源，并用Request-URI作为其标识) DELETE(请求服务器删除Request-URI所标识的资源) OPTIONS(请求查询服务器的性能，或者查询与资源相关的选项和需求) TRACK(请求服务器回送收到的请求信息，主要用于测试或诊断) CONNECT(保留将来使用) GET请求为例如下：GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 第一部分，请求行：格式如下：方法 [空格] 请求URI [空格] 版本号 [回车换行]Method&nbsp;Request-URI&nbsp;HTTP-Version CRLF（CRLF表示回车和换行，除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。例如：GET&nbsp;/form.html&nbsp;HTTP/1.1&nbsp;(CRLF) 第二部分，请求头部。紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等。 第三部分：空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。这个例子的请求数据为空。HTTP协议之Response一般般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。一个完整的response如下：HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8空行&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;!--body goes here--&gt;&lt;/body&gt;&lt;/html&gt; 第一部分，状态行。格式如下：版本号 [空格] 状态码 [空格] 原因 [回车换行]例子中（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分，消息报头，用来说明客户端要使用的一些附加信息。例子中第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分，空行，消息报头后面的空行是必须的 第四部分，响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。HTTP状态码状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值： 1xx：指示信息–表示请求已接收，继续处理 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 2xx：成功–表示请求已被成功接收、理解、接受 200——交易成功 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 3xx：重定向–要完成请求必须进行更进一步的操作 300——请求的资源可在多处得到 301——删除请求数据 302——在其他地址发现了请求数据 303——建议客户访问其他URL或访问方式 304——客户端已经执行了GET，但文件未变化 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 4xx：客户端错误–请求有语法错误或请求无法实现 400——错误请求，如语法错误 401——未授权 HTTP 401.1 - 未授权：登录失败 HTTP 401.2 - 未授权：服务器配置问题导致登录失败 HTTP 401.3 - ACL 禁止访问资源 HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 402——保留有效ChargeTo头响应 403——禁止访问 HTTP 403.1 禁止访问：禁止可执行访问 HTTP 403.2 - 禁止访问：禁止读访问 HTTP 403.3 - 禁止访问：禁止写访问 HTTP 403.4 - 禁止访问：要求 SSL HTTP 403.5 - 禁止访问：要求 SSL 128 HTTP 403.6 - 禁止访问：IP 地址被拒绝 HTTP 403.7 - 禁止访问：要求客户证书 HTTP 403.8 - 禁止访问：禁止站点访问 HTTP 403.9 - 禁止访问：连接的用户过多 HTTP 403.10 - 禁止访问：配置无效 HTTP 403.11 - 禁止访问：密码更改 HTTP 403.12 - 禁止访问：映射器拒绝访问 HTTP 403.13 - 禁止访问：客户证书已被吊销 HTTP 403.15 - 禁止访问：客户访问许可过多 HTTP 403.16 - 禁止访问：客户证书不可信或者无效 HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 404——没有发现文件、查询或URl 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。 5xx：服务器端错误–服务器未能实现合法的请求 HTTP 500 - 内部服务器错误 HTTP 500.100 - 内部服务器错误 - ASP 错误 HTTP 500-11 服务器关闭 HTTP 500-12 应用程序重新启动 HTTP 500-13 - 服务器太忙 HTTP 500-14 - 应用程序无效 HTTP 500-15 - 不允许请求 global.asa Error 501 - 未实现 HTTP 502 - 网关错误 HTTP协议之请求头HTTP最常见的请求头如下： Accept:浏览器可接受的MIME类型； Accept-charset：浏览器可接受的字符集； Accept-Encoding: 浏览器能够解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间； Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到； Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中； Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小； Content-Length：表示请求消息正文的长度； Cookie：这是最重要的请求头信息之一； From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它； Host：初始URL中的主机和端口； If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答； pragma：定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝； Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。 User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用； UA-Pixel,UA-Color,UA-OS,UA-CPU:由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。 HTTP之响应头HTTP最常见的响应头如下所示： Allow：服务器支持哪些请求方法（如GET、POST等）； Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和NAME类型的对应关系； Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面； Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容； Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦； Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。 Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置； Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302； Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的&lt;META HTTP-EQUIV=&quot;Refresh&quot; CONTENT=&quot;5;URL=http://host/path&quot;&gt;实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 ###HTTP之实体头实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。 Allow：GET,POST； Content-Encoding：文档的编码（Encode）方法，例如gzip,见“HTTP之响应头”； Content-Language：内容的语言类型，例如：zh-cn； Content-Length：表示内容长度，eg:80,可见“HTTP之响应头”； Content-Location：表示客户应当到哪里去提取文档，可见“HTTP之响应头”； Content-MD5：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较； Content-Range：随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度； Content-Type：标明发送或者接收的实体的MIME类型； Expires：为0证明不缓存； Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT. HTTP之扩展头在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。 Refresh：1;url=http://www.dfdf.org //过1秒跳转到指定位置； Content-Disposition：头字段,可参考“2.5响应头”； Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。 GET方式和POST方式的区别：GET方式：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。POST方式：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能： 对现有资源的解释； 向电子公告栏、新闻组、邮件列表或类似讨论组发信息； 提交数据块； 通过附加操作来扩展数据库 。从上面描述可以看出，Get是向服务器发索取数据的一种请求；而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。GET方式和POST方式有以下区别： 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。 get和post理论上都没有数据大小限制，但是浏览器本身对url长度有限制，IE为2083B，火狐、chrome等为4098B。post数据时无论多大都不会报错，而是浏览器会崩溃。还有服务器端对数据大小可能会有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。 安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。 URI和URL的区别URI（Uniform Resource Identifier）是统一资源标识符，而URL（Uniform Resource Location）是统一资源定位符。因此，笼统地说，每个URL都是URI，但不一定每个URI都是 URL。这是因为URI还包括一个子类，即统一资源名称(URN)，它命名资源但不指定如何定位资源。区别如下： 在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。 Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的，URI一般由三部组成: 访问资源的命名机制 存放资源的主机名 资源自身的名称，由路径表示，着重强调于资源。 URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成: 协议(或称为服务方式) 存有该资源的主机IP地址(有时也包括端口号) 主机资源的具体地址。如目录和文件名等 Session和Cookie的区别Cookie和Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力。 Session可以用Cookie来实现，也可以用URL回写的机制来实现。用Cookie来实现的Session可以认为是对Cookie更高级的应用。 Session和Cookie区别： Cookie将状态保存在客户端，Session将状态保存在服务器端； Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义； Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器； 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些.因为它不会任意读取客户存储的信息。 HTTP协议是无状态的和Connection:keep-alive的区别状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系 HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接） 从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间]]></content>
      <categories>
        <category>TCP/IP协议</category>
      </categories>
      <tags>
        <tag>HTTP协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议简介]]></title>
    <url>%2F2018%2F02%2F03%2FTCP%20IP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TCP/IP协议TCP/IP协议的由来 在世界各地，各种不同电脑运行着各种不同的操作系统为大家服务，这些电脑在表达同一种信息的时候所使用的方法千差万别，无法合作。所以人们就想方设法将它们联合起来，发挥出它们最大的潜力。但简单连接起来是不够的，它们还需要定义一些共同的东西来进行交流沟通，TCP/IP协议由此而生。 TCP/IP协议简介 TCP/IP协议不是一个协议，而是一个协议簇的统称。里面包括：HTTP、FTP、SMTP、SIP、SNMP、TCP、UDP、SCTP、ICMP、ARP、PPP等等。 TCP/IP协议中有一个重要的概念是分层。按照层次分为以下四层： 链路层： 用来处理网络的硬件部分。包括操作系统、硬件的设备驱动、NIC（NetWork Interface card 即网卡）、以及光纤等物理可见部分。还包括连接器等传输媒介。硬件上的范畴均在链路层的作用范围之内 网络层： 用来处理在网络上流动的数据包。数据包是网络传输的最小单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传给对方。 与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多选项内选择一条传输路径 传输层：TCP(Transmission Control Protocol传输控制协议 )、UDP(User Data Protocol用户数据报协议) 应用层： FTP（File Transfer Protocol文件传输协议）、DNS(Domain Name System域名系统)、HTTP（Hyper Text Transfer Protocol超文本传输协议） 网络上的TCP/IP通信数据流如下：发送端每通过一层则增加首部，接收端每通过一层则删除首部发送端： 应用层（HTTP数据）———————传输层（HTTP数据增加了TCP首部）————网络层（在传输层传过来的数据增加了IP首部）————链路层（增加了以太网首部）接收端：从链路层到应用层每通过一层删除相应的首部 基本常识 互联网地址（IP地址）网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。 域名系统域名系统是一个分布的数据库，它提供将主机名（就是网址啦）转换成IP地址的服务。 RFCRFC就是tcp/ip协议的标准文档 端口号（port）服务器一般都是通过知名端口号来识别的。例如，对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21，每个Telnet服务器的TCP端口号都是23，每个TFTP (简单文件传送协议)服务器的UDP端口号都是69。任何TCP/IP实现所提供的服务都用知名的1～1023之间的端口号。这些知名端口号由Internet号分配机构（Internet Assigned Numbers Authority, IANA）来管理。知名端口号介于1～255之间；256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务；1024~5000端口号用于客户端分配临时端口号；大于5000的端口号是为其他服务器预留的。 TCP/IP协议之HTTP协议HTTP全称是HyperText Transfer Protocal，即：超文本传输协议，从1990年开始就在WWW上广泛应用，是现今在WWW上应用最多的协议， Http是应用层协议，当你上网浏览网页的时候，浏览器和Web服务器之间就会通过HTTP在Internet上进行数据的发送和接收。Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。 TCP/IP协议之TCP协议TCP协议属于传输层，提供可靠的字节流服务。即将大块数据分割成以报文段（sagment）为单位的数据包进行管理。而可靠的传输服务是指能把数据准确可靠的传给对方。简而言之，TCP为了更容易传送大数据才发数据分割，并且能够确认数据最终是否达到对方。 为了确保信息能够准确无误的到达，TCP采用了著名的三次握手，四次分手策略。连接时的三次握手： 建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认。 服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态。 客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。断开是的四次挥手 客户端发送一个FIN，用来关闭客户到服务器的数据传送。 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 服务器关闭与客户端的连接，发送一个FIN给客户端。 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。 客户端在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），才进入到CLOSED状态。为什么？ 为了保证发送的最后一个ACK报文段能够达到服务器 防止“已失效的连接请求报文段”出现在本连接中 TCP/IP协议之UDP协议TCP/IP协议之IP协议IP（internet protocol）,这里IP不是指我们通常所说的IP地址（如192.168.1.1），而是一种协议。IP协议的作用在于把各种各样的数据包准确无误的传递给对方，其中两个重要的条件是IP地址和MAC地址（Media Access Control Address）. TCP/IP协议之DNS协议]]></content>
      <categories>
        <category>TCP/IP协议</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向过程和面向对象的区别]]></title>
    <url>%2F2018%2F02%2F03%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[面向过程优点：性能比面向对象高，因为面向对象类的调用需要实例化，开销比较大，比较消耗资源；比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点：没有面向对象易维护、易复用、易扩展 面向对象优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。 面向对象和面向过程的区别 面向对象的四大基本特征：封装、抽象、继承、多态。 面向对象的封装性，即将对象封装成一个高度自治和相对封闭的个体，对象状态（属性）由这个对象自己的行为（方法）来读取和改变。比如张三这个人，他的姓名等属性，要有自己提供的获取或改变的方法来操作（get、set方法）。 抽象就是找出一些事物的相似和共性之处，然后将这些事物归为一个类，这个类只考虑这些事物的相似和共性之处，并且会忽略与当前主题和目标无关的那些方面，将注意力集中在与当前目标有关的方面。 就是把现实生活中的对象，抽象为类。 在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并可以加入若干新的内容，或修改原来的方法使之更适合特殊的需要，这就是继承。 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 多态的缺点：多态后不能使用子类特有的属性和方法。 多态的好处1减少代码量]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重写（override）和重载(overload)的区别]]></title>
    <url>%2F2018%2F02%2F03%2F%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.重写（override）和重载(overload)的区别方法重载是让类以统一的方式处理不同数据类型的一种手段。多个同名函数同时存在，但具有不同的参数个数/类型。重载是一个类中多态的一种体现。 Java的方法重载，就是在一个类中可以创建多个方法，他们具有相同的名字，但有不同的参数和不同的定义。调用方法时通过传入参数的个数和类型来决定具体使用哪种方法，这就是多态性。 方法重写是父类和子类之间多态性的体现。子类对父类的方法进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Override)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改。这就需要方法的重写。方法重写又称做方法覆盖。 如果子类的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法覆盖原有的方法，如需要用父类中原有的方法，可以使用super关键字引用当前类的父类。 总结： 方法重写（override） 方法名、参数、返回值类型必须相同； 子类方法不能缩小父类方法的访问权限； 子类方法不能比父类方法抛出更多的异常（子类也可以不抛异常）； 存在于父类和子类之间； 被覆盖的方法不能为private,否则在子类中只是重新定义了一个方法，并没有对其进行覆盖； 方法被定义为final不能被重写。 方法重载（overload） 参数类型、个数、顺序至少有一个不一致（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）； 不能重载只有返回值不同的方法。 方法的异常类型和数目不会对重载造成影响； 存在于父类、子类和同类中； 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F02%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计原则 单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 里氏替换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。 开放-封闭原则：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 设计模式单例模式单例模式是一种常用的软件设计模式，它的核心结构中值包含一个被称为单例的特殊类。它可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而控制实例个数并节约系统资源。 实现思路：单例模式要求类能够有返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法），主要通过以下两个步骤实现： 将该类构造方法定义为私有方法，这样其他代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来获得该类的唯一实例 在该类内部提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。 单例模式常见的写法： 饿汉式（不推荐使用）： 12345678910public class Singleton&#123; //static final单例对象，类加载的时候就初始化 private final static Singleton instance = new Singleton(); //私有构造方法，使得外界不能直接new private Singleton()&#123;&#125; //公有静态方法，对外提供获取单例接口 public static Singleton getInstance()&#123; return instance; &#125;&#125; 优点：线程安全。 缺点：不支持懒加载。加载这个类时就实例化了instance，浪费内存，影响性能。 懒汉式（不推荐使用） 12345678910public class Singleton&#123; private static Singleton instance; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优点：单例对象在第一次调用时才被实例化，有效节省内存，并且保证了线程安全。 缺点：同步是针对方法的，以后每次调用getInstance时（即使instance已经被实例化了），也会进行同步，造成不必要的同步开销。 双重检查（推荐用） 1234567891011121314public class Singleton&#123; private static volatile Singleton instance; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(instance == null)&#123; synchronized(Singleton.class)&#123; if(instance == null)&#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优点：线程安全；延迟加载；效率较高 静态内部类（推荐用） 123456789public class Singleton&#123; private Singleton()&#123;&#125; private static class SingletonInstance&#123; private static final Singleton instance = new Singleton() &#125; public static Singleton getInstance()&#123; return SingletonInstance.instance &#125;&#125; 优点：避免了线程不安全，延迟加载，效率高。 枚举（推荐用） 123456public enum EnumSingleton&#123; instance; public static void whateverMethod()&#123; &#125;&#125; 优点：系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。 缺点：当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2018%2F02%2F03%2F%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88constructor%EF%BC%89%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%ABOverride%2F</url>
    <content type="text"><![CDATA[构造器是干什么用的？构造器是用来生成一个类的实例并初始化这个实例用的。 构造器如何工作？Java在构造实例时的顺序如下： 分配对象空间，并将对象中成员初始化为0或者空，java不允许用户操纵一个不定值的对象。 执行属性值的显式初始化。 执行构造器。 将变量关联到堆中的对象上。 执行构造器的步骤可以分为以下几步： Bind构造器的参数 。 如果显式的调用了this，那就递归调用this构造器然后跳到步骤4 。 递归调用显式或者隐式的父类构造器，除了Object以外，因为它没有父类。 执行显式的实例变量初始化（也就是上边的流程中的第二步，调用返回以后执行，这个步骤相当于在父构造器执行后隐含执行的，看样子像一个特殊处理）。 ###构造器不可被override其实你只需要记住一句话：构造器不是方法，不能被子类继承。，所以Constructor也就不能被override。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造函数。用来修饰方法特性的所有修饰符都不能用来修饰构造器（并不等与构造器具备这些特性，虽然不能用static修饰构造器，但它却有静态特性）构造器只能用 public private protected这三个权限修饰符，且不能有返回语句。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0入门]]></title>
    <url>%2F2018%2F02%2F03%2Fvue2.0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吾日三省吾身]]></title>
    <url>%2F2018%2F02%2F03%2F%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[吾日三省吾身每天进步一点点 2018年共运动37天2018年共读书2本 2018-04-24 以后自己有思路能实现的尽量自己写，不要照着别人的思路来，不踩坑永远填不了坑。 利用好自己的时间，完成自己该干的事。 学会变通，加油！！ 2018-04-23 晚上回来八点多，啥也没干就十点多了，学习时间也只剩一点了。得安排好时间，合理利用。 有些多试试就做出来了，并且有些bug自己也能调出来，自己能做出来的时候尽量自己做，不要依赖别人 加强技能，加油！！ 2018-04-22 感觉每个周末都利用的不是特别好，除了学习外的其他事情基本都能完成，为很美学习完成不了呢？ 学会总结，遇到问题不要放过，解决并总结，并且过一段时间返回来看一遍。 学会自省，加油！！ 2018-04-21 房间终于收拾的差不多了，希望明天可以坐着多学会。 想要做的事就要努力去完成，别被其他因素干扰，只要想做，总会完成的 实现自我，加油！！ 2018-04-20 遇到问题多深究，去了解思路以及底层实现，并加强练习，才能变成自己的知识 真的是熬不了夜了，熬一个夜要花好长时间去缓过来。 重复学习，加油！！ 2018-04-19 好多天没写三省了，坚持了这么久的三省就这样断了，现在也收拾的差不多了，争取不断了。 尽量多抽点时间来学技术，加强专业技能，只有这样才能有更多选择。 深入学习，加油！！ 2018-04-16 终于搬完家收拾出点眉目了，以后东西要收拾整齐，做个干净整洁的人。 遇到事情不要觉得简单而拖延，要动手去做，有可能会发生很多自己没想到的问题 脚踏实地，加油！！ 2018-04-13 拿到项目多沟通，不要按照自己的想法开发，要不然只会给自己挖坑 不能急躁，但也不能懈怠，尽可能提高效率，抽出更多时间来学习自己想要学的 坚持下来，加油！！ 2018-04-12 多注意分析，多沟通，不要自己猜想做无用功。 注意提高效率，完成自己给自己定的任务。 逐渐完善，加油！！ 2018-04-11 写代码速度还是有点慢，有些知识知道，但是不能很好的利用，多练习 多注意细节方面的东西，不要因为一个字母的失误卡在那好长时间，浪费时间 认真仔细，加油！！ 2018-04-10 遇事看开点，想开点，开心最重要 自己还是不够强大，不能改变什么，好好努力 不断变强，加油！！ 2018-04-09 执行力还是不够，有时候计划挺多的，但是就是拖拖拉拉，要注意加强 可以多看看别人的代码，取长补短，让自己的代码更高效，更合理 督促自己，加油！！ 2018-04-08 人与人之间为什么会有那么多套路，不累吗，有啥直接说不好吗？ 自己还是不够熟练，有的样式不咋能调过来，速度也有点慢 掌控自己，加油！！ 2018-04-07 感觉有些事考虑的越来越多了，不知道是好还是不好。只是不愿意改变吗？ 任何时候花费在读书和学习的时间总会在某些特定的时候得到回报。 不断成熟，加油！！ 2018-04-06 这周末挺好的，能做到早睡早起，轻轻松松的 今天虽然学习了，但是好多时间都往返于洗衣服搭衣服的路上。 学会总结，加油！！ 2018-04-05 放假第一天，下了一天雨，可以说出去玩了一天吧，晚上回来睡了一觉，起来准备洗了继续睡，美滋滋 明天就要进入学习状态，再看看书 学会生活，加油！！ 2018-04-04 写代码中还是有很多细节要注意，有时候错误就是以为一个很小很小的失误 又放假了，希望这次是真的可以利用好吧 好好规划，加油！！ 2018-04-03 接触新知识时感觉很难，但有的稍微用几次就懂了，多动手，不要只在那想 规范自己的代码，养成良好的习惯 规范自己，加油！！ 2018-04-02 慢慢养成了早起的习惯，希望周末也能早起就好了 多交流，有不会的就提出来，多问问，才能学到更多。 勤学苦练，加油！！ 2018-04-01 内心有想做的事情就去实施，一直拖着既浪费时间又影响心情 这两天发生的事，感觉有些事有时候真的好巧 把想法转变为行动，加油！！ 2018-03-31 以后一定改掉晚上吃完饭睡觉的习惯，既对身体不好还花费时间 过好每个周末，适当出去走走，呼吸呼吸外面的空气 坚持下来，加油！！ 2018-03-30 又是一个周末，可以适当放松下，但不能忘了学习 希望不浪费周末时间，抓紧时间练习。 劳逸结合，加油！！ 2018-03-29 还是有很多知道知识不能理解，甚至是不认识，努力弄懂 这两天晚上回来都没睡了，感觉也还好，坚持下来 做好自己，加油！！ 2018-03-28 多练习，多尝试，多看书，多思考，多总结 坚持下来，充分利用好每段时间，希望可以不断提升 加强效率，加油！！ 2018-03-27 每天晚上刚回来就累的不行，得睡半小时，得找个方法让自己不睡觉或者睡少一下，把晚上时间充分利用起来。 好久没有正儿八经的看过书了，把乘地铁的时间利用起来，多读会书。 把时间利用的更好，加油！！ 2018-03-26 好像每天也没有那么累，平时多注意身体就好了 要学会把在地铁上和公交上的时间利用起来，应该会收获好多吧 逐步提升，加油！！ 2018-03-25 调整每天的状态，把每天的状态调到最好 碰见问题解决后记录下来，方便下次寻找，以便更好地进步 学会解决问题，加油！！ 2018-03-24 有时候一个功能的实现就差一点，其实已经有思路了，再多查点，多试几次说不定就可以实现了。 用心去做事，有的事不是差不多就行了。 不断提升自我，加油！！ 2018-03-23 自己对技术点的了解还是不够深入，不能合理利用自己知道的技术 完成任务的速度有点慢，好好打好基础，加快速度 多努力，加油！！ 2018-03-22 前一天晚上把第二天都要带的东西都准备好，要不匆匆忙忙容易落下东西 多了解新技术，更新自己的技术 希望自己在前进的道路上越走越远，越走越快，加油！！ 2018-03-21 熟能生巧，不熟悉的一定要多加练习，增加熟练度 不会的多查查，多了解，不要只做代码搬运工 相信自己，加油！！ 2018-03-20 没有什么事情是一定做不到的，就看想不想做，有多想。 注意不要坐太久，坐直身子，过一段时间稍微活动活动，多喝水 别让自己失望，加油！！ 2018-03-19 自己真的是有太多的不会 比别人懂得少，就要比别人更刻苦 当天有问题当天解决，加油！！ 2018-03-18 不能生活的太安逸，安逸就会颓废 碰到不会的不要想着放弃，而应该想着如何解决。才会成长。 多了解，多练习，多总结。加油！！ 2018-03-17 多喝水，没事的时候看看书，不能躺床上。 学会利用时间，时间才能更多。 朝着目标不断努力，加油！！ 2018-03-16 不断巩固基础，了解新知识，提升专业水平 啥事最提前做好准备，想好对策，拒绝拖延。 多读书，没事时规划规划，加油！！！ 2018-03-15 给自己定个大目标，再分段定个小目标，朝着目标前进。 认真学好每一个知识点，并进行总结，一步一个脚印，夯实基础。 明确方向，加油！！ 2018-03-14 最近节奏慢慢步入正轨了，差不多做到早睡早起了，要是能熬过晚上吃完饭犯困就更好了 感觉每天能掌握的知识好有限，并且又会延伸出其他问题 相信自己可以得，加油！！ 2018-03-13 每天早上起床先定个小目标并记下来，然后努力去完成 自己感兴趣的事情就要挤出时间去了解，去完成 严格要求自己，加油！！ 2018-03-12 坚持下去就会有收获，背单词虽然第一眼不知道具体什么意思，但是已经错的比原来少了，就好像有种感觉似的。 干啥事情都要注意安全，不要心存侥幸 只有自己足够强大，才能更加自信！ 加油！！ 2018-03-11 要尽量弄清原理，而不仅仅是如何使用 不懂得问题要多看多问多查多讨论，才能加深记忆 每天学习英语，加强学习能力，加油！！ 2018-03-10 尽量不要睡太晚，要养成早睡早起，而不是熬夜晚起 对于知识要尽量往深理解。 利用好空余时间，才能更高效，加油！！ 2018-03-09 每天睡觉前回顾和反思一下，整理下自己学到的东西 保持一个良好的心态 一步一个脚印，踏踏实实走下去，加油！！ 2018-03-08 学到新知识点时要多练习巩固，才能更好的运用 学习时要注重质量和效率，在保证质量的前提下尽量提高效率 努力的人运气不会差的，加油！！ 2018-03-07 最近晚上睡得迟了，状态不咋好，等会早点睡，明天早起，把状态调回来 控制住自己，时刻给自己充电 多练练英语，加强自己能力。加油！！ 2018-03-06 认真弄懂每一个知识点，不断挖掘其深度 静下心来，找到状态。 要干就把一件事干好，加油！！ 2018-03-05 越来越感觉自己不懂的太多了，多读书充充电。 不放过任何一个疑问，不将就。 踏踏实实，做好每一件事。加油！！ 2018-03-04 一天就这么过去了，感觉自己好像啥也没干，但好像也没有荒废 啥事坚持的时间长了，内心想要放弃时就会不舍。所以当想干一件事时，请坚持下来。 做好自己，加油！！ 2018-03-03 忙碌又充实的一天，虽然很累，但是感觉挺好的。 感觉晒太阳的感觉真好。 其实自己一天时间挺多的，自己也没有想想中的那么弱。加油！！ 2018-03-02 要合理安排任务，分清主次，依次完成 其实没事的时候看看书也挺好，哪怕很粗略的看过去，也总会有一些收获 坚定的走下去，加油！！ 2018-03-01 2月份三省断了很多天，这几天晚上状态也不是特别好，今晚慢慢改过来了 尽快调整自己的状态，运动也要开始 要自信不要怂！加油！！ 2018-02-27 这两天状态都还可以，希望可以尽快给自己一个交代 新的开始，要注意长时间集中注意力 自己想要的就要努力去达到，加油！ 2018-02-24 时间过得好快，明天又要走了，感觉才刚到家 到了之后好好努力，不要拖延 加强自己的实力，要掌控自己的生活，加油！ 2018-02-23 充分利用好每天的空闲时间 做事情要专注，才能更高效率 自己要掌控自己 2018-02-22 合理安排每一天，并尽最大可能按照规划来 早睡早起，感觉在家睡得有点迟了 不要轻易放弃，加油！ 2018-02-21 把握每一天 要想变强，就不能让自己过的太舒坦 多问为什么，多想想原因 2018-02-20 时间过的真快，又要走了，有点不舍 注意休息，不要过度用眼 多喝水，身体才是最重要的 2018-02-19 现在是奋斗的年纪，趁年轻，多想多做 充分利用好空余时间，总会学到点东西 有时事情别想太多，心里过的去就行 2018-02-18 感觉最近几天休息不好，一到快晚上就特别困。 今天还做了会运动，感觉挺好的。 不要心烦，保持一个良好心态，加油！ 2018-02-17 没事干的时候在家学习也挺好的。 最近也没咋做运动了，不能松懈 多喝水，多看书，加油！ 2018-02-16 新年新气象，今天没有学习，继续开始学习了要 在家也要适当做点运动 要更加努力，加油 2018-02-15 回到家三省好几天没写了，尽量每天都写 今天打扫了一天卫生，干了挺多活的。 除夕了，新的一年加油！ ###2018-02-08 坚持了三十三天的运动就这样断了，到点了感觉缺点什么 晚上收拾了东西，明天回家 一本书终于快要看完了，加油！ ###2018-02-07 不要因为懒而不去做心中想做的事情 不断学习，才能提高自己 坚持锻炼第三十三天，加油 2018-02-06 每天完成既定任务，必须完成!不拖延 遇到问题不要烦躁，而是思考如何去解决它 坚持锻炼第三十二天，加油 2018-02-05 今天表现还可以，继续努力 多查查，遇到问题要弄的完全明白 坚持锻炼第三十一天，加油！ 2018-02-04 下午去理了个发，等了好长时间 尽量每周写一篇Blog吧 坚持锻炼第三十天，加油 2018-02-03 昨晚弄Blog弄太迟了，早上就睡过去了，尽量不熬夜了 只有尽最大的努力，才能达到自己想要的结果。做自己所能做的，不留遗憾 坚持锻炼第二十九天，加油 2018-02-02 学会控制自己，冷静解决问题 遇到事情多问为什么 坚持锻炼第二十八天，加油！ 2018-02-01 选择了就继续走下去，犹豫只会耽搁时间 越看觉得自己不懂得越多 坚持锻炼第二十七天，加油！ 2018-01-31不拖延不敷衍 合理安排每件事，找到最适合自己的方法 每天梳理下自己学到的 坚持锻炼第二十六天，加油！ 2018-01-30认真规划，认真完成 昨晚睡的太迟了，不过完成了自己想要做的 今天表现的还不错，继续加油 坚持锻炼第二十五天，加油！ 2018-01-29每天早起先规划一下自己的任务，并去完成 终于又有一天早起了，希望坚持 做事情时集中精力，高效去完成 坚持锻炼第二十四天，加油！ 2018-01-28不要给自己想要做的事情找放弃的理由，因为一旦有一点松懈，就可能会因为懒惰而放弃 调整每天的状态，做到自律 以后还是尽量少把时间花在做饭上 坚持锻炼第二十三天，加油！ 2018-01-27 天气好冷今天，躲被窝就不想出来 来的票买好了，不用再想这方面的事了 坚持锻炼第二十二天，加油，相信可以一直坚持下去的 2018-01-26 晚上买了个服务器，研究了研究 又要买来的票了，又是一场战争 坚持锻炼第二十一天，加油，不知道二十一天养成习惯了吗，不过还是希望坚持下去 2018-01-25 早上要战胜寒冷，冲出被窝 今天下雪了，晚上出去看了看雪 坚持锻炼第二十天，加油 2018-01-24 加大每天读书时间，充分利用好时间 要能控制自己，拒绝拖延 坚持锻炼第十九天，加油！ 2018-01-23 遇到问题多尝试去解决，就会解决掉 多读书，看源码 坚持锻炼第十八天，加油！ 2018-01-22 做了自己想做的事情，加油 注意每天多读书 坚持锻炼第十七天，加油！ 2018-01-21最重要的不是做何选择，而是做了选择之后如何让去做 今天感觉时间都利用的挺好的，就是感觉时间不够用 越看的多越觉得自己会的少 坚持锻炼第十六天，加油！感觉这两天每天做完每组运动休息时间有点长，明天注意一下 2018-01-20不要怕做不出来，要努力去做，不做永远也做不出来 今天早上起迟了，不过起来之后都利用的挺好的，没有浪费时间 要快速进入状态，认真学习 坚持锻炼第十五天，加油！不知道养成一个习惯要多久 2018-01-19 晚上一不小心就睡过去了，导致一系列的计划都推迟了，要控制 遇到问题主动去解决，并总结下来 坚持锻炼第十四天，加油！ 2018-01-18想做的事情就要用于尝试去做 这两天表现都还挺好的，也没有咋浪费时间 寻找高效的方法，学会学习 坚持锻炼第十三天，加油！ 2018-01-17 保持状态，好好学习巩固基础 合理安排好时间，完成自己想要做的每一件事 坚持锻炼第十二天，加油！ 2018-01-16 今天白天表现基本不错，这两天晚上的表现都不是特别好。调整下 要抽出两小时看书 坚持锻炼第十一天，加油! 2018-01-15 今天白天表现基本不错，晚上头疼，睡了一个多小时. 今天没有抢到票 坚持锻炼第十天，加油! 2018-01-14最难的事情就是战胜自己 这个周末都荒废了，基本全玩游戏了 这周开始看第一本书，并好好总结 坚持锻炼第九天，终于看见两位数的影子了 2018-01-13坚持，不找借口 今天一天都没咋学习，需要静下心来，好好调整状态 开始看集合类源码，加油 坚持锻炼第八天。 2018-01-12静下心来认真做好自己想做的每一件事 静下心来，做好一天，并认真总结 学会调整状态 坚持锻炼第七天，离两位数不远了，坚持住 2018-01-11每天做好规划 感觉每天时间都利用的不够充分，每天做好规划，并按照计划完成 抢到了回家的票(^ _ ^) 坚持早起第三天，坚持锻炼第六天，加油 2018-01-10挑战自己 早上早起成功。状态也不错 晚上研究了回家的火车票，所以没有学习，也睡晚了。。 坚持锻炼第五天，希望明天可以早起，明天补个面试题，加油！ 2018-01-09不怕学的慢，就怕坚持不下来 今天早上起来了，不过还不够早 加强技能训练，不断完善知识树 坚持锻炼第四天 2018-01-08最大的挑战就是自己 什么时候才能早起，今晚稍微睡早点看能起来吗。 每天起床其实并不是有多累，其实就是那么一念间 坚持锻炼第三天 2018-01-07学会控制自己，按照自己的思想生活 一到周末就会晚睡晚起，得改掉这个习惯 今天下午跟晚上表现挺好的，坚持，加油！ 坚持锻炼第二天，多读书 2018-01-06合理安排好每一件事，劳逸结合 今天出来早上没起来之外表现都还挺好的 以后每天抽出点时间读读书，看一段时间得歇会眼睛，要不眼睛容易疼 坚持锻炼第一天。啥时候这个数字能大于10. 2018-01-05想要坚持一件事是真的难 早上没有起的特别早，明天争取7.30起床 晚上没有咋学习，看电视时间长了睡着了，以后晚上尽量不看电视了 运动又没做，睡起来迟了。以后规划好，坚持下去 2018-01-04时间都是挤出来的，好好规划，要不总觉得没有时间 今天把自己想做的都做了，坚持下去 昨天断的锻炼又开始了，继续坚持 今晚早早收拾好早睡，调整作息 2018-01-03感觉每天时间都不够用，合理安排好自己的每一天时间 晚上没有做运动 今天时间利用的倒挺好的，收获也蛮多。 最近晚上睡的有点晚了感觉 2018-01-02早起第一天，虽然还没能达到心中想要起的时间，但确实比之前早挺多的，新的一天，加油！ 今天一天表现还行，也没有浪费啥时间。就是再提高提高效率就好了 晚上去理了个发，所以少学了一会 坚持早起第一天，坚持运动第三天。也不知道坚持多少天能养成习惯 2018-01-01今天给自己想的任务可以说一个都没有完成吧，但是也算是努力去做了 昨晚又熬夜了，并且还是玩游戏。批评一下，下不为例 晚上吃饭还是没有熬过去，又睡着了。吃完饭后不能躺床上了，一躺就想睡觉 坚持运动第二天。以后立任务要结合实际，不能总是任务太多而做不完。 2017-12-31坚持自省第二天，希望能养成习惯 早上起的倒不是特别迟了，但是赖被窝好长时间。改掉这个坏习惯！ 17年最后一天了，过的还行吧，白天没有学习，不过晚上还利用的挺好的。 明天就是新的一年了，希望自己能够完成自己想要完成的东西。 2017-12-30好久没有自省过了，感觉坚持一件事情好难，什么时候才能做到坚持自己想做的事情。加油！ 早上起来的太迟了，昨晚睡得太早。还是早睡早起好，睡得迟既起的迟，精神状态还不好 下午的时间还利用的挺好的，不过还有进步空间。 要坚持锻炼，每天看一道面试题，加油！！！！！ 2017-11-06 今天面试完回来没有安排好路线，等公交浪费了挺长时间 得赶紧找点项目做 博客要每天总结学到的东西 2017-11-05 明天有个面试，加油！ 好像周末早睡早起就比较容易断了 总结的多线程还没有总结完 2017-11-01 吾日三省吾身断了好多天了，因为搬家断了一直没有续上，现在继续，加油 最近终于可以早起了，希望坚持下去 没有完成自己规定的任务，下次任务一定好好规划，争取完成 2017-10-18 这几天晚上睡得有点迟了，主要是早上起不来 以后尽量中午休息一会，晚上不能睡了，要好好加油 每天都没有完成指定好的任务，要把一天安排的充实一点 2017-10-17 早上虽然没有早起，但是已经比之前强了点，希望继续努力 下午学习效率还行，比之前有进步 晚上吃饭的时候看电视时间太长了，并且因为懒没有去跑步 2017-10-16 要坚持下来自己想要坚持的 减少看手机时间 静下心来，提高学习效率 2017-10-15 希望之前几天提到的不好的一定要改掉 连续下雨，看来跑步暂时是不行了 希望能静下心来，好好学习 2017-10-14 今天早上不仅没起来，还起的特别迟（啊啊啊啊，什么时候才能早起呀） 今天白天都没有好好学习，并且也没有好好吃饭（加油啊，一定不能再这样了） 晚上睡得迟了（下午吃完饭睡了一觉，以后尽量不这样，会形成恶性循环的） 2017-10-13 早上又没起来（其实也不算特别累，但就是没起来，希望明天这个不要再出现了） 感觉得保护保护眼睛，看一段歇一段时间 晚上没有跑步（因为去看房子了） 2017-10-12 早上又没有起来（前一天晚上睡觉的时候总想着一定起来） 学习效率不咋高，没有充分利用好晚上的时间，不过比之前晚上有了一点点进步了 晚上也没有跑步，或许因为下小雨，但其实还是因为自己懒了]]></content>
      <categories>
        <category>自省</category>
      </categories>
      <tags>
        <tag>自省</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试题]]></title>
    <url>%2F2018%2F02%2F03%2F%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[笔试题JS中”==”和”===”的区别js中两个等号(==)和三个等号(===)的区别： “==”表示：equality -&gt; 等同 的意思，”==”使用两个等号时，如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较。 “===”表示：identity -&gt; 恒等 的意思，”===”使用三个等号时，是不需要做类型转换的，如果两边值的类型不同，就表示一定是不等的。 简单说明使用三个等号(===)的判断规则： （1）如果类型不同，就一定不相等 （2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断） （3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。 （4）如果两个值都是true，或是false，那么相等 （5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等 （6）如果两个值都是null，或是undefined，那么相等 简单说明使用两个等号(==)的判断规则： （1）如果两个值类型相同，再进行三个等号(===)的比较 （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较： 1）如果一个是null，一个是undefined，那么相等 2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较 JS中使用typeof能得到哪些类型返回值类型：string类型，有可能是：string、number、boolean、undefined、object、function前4个是值类型，后2个是引用类型 java四种级别修饰符以及访问权限 public:用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问； protected: protected修饰符的修饰的成员变量和方法也称为受保护的成员变量和方法， 受保护的成员变量和方法可以在本类或同一个包中的其它类（包括子类）中通过类的实例进行访问，也可以被同一个包中的类或不同包中的类继承，但是不能在不同包中的其它类（包括子类）中通过父类的实例进行访问。可以通过子类的实例进行访问 default(friendly): 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。 private:用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。注意：java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。 静态变量和实例变量（非静态变量）的区别 语法上：静态变量前要加static关键字，而实例变量前则不加。 内存分配：静态变量在应用程序初始化时，就存在于内存当中,直到它所在的类的程序运行结束时才消亡；而实例变量需要被实例化后才会分配内存。 生存周期：静态变量生存周期为应用程序的存在周期；实例变量的存在周期取决于实例化的类的存在周期。 调用方式：静态变量只能通过“类.静态变量名”调用，不推荐类的实例化后调用；实例变量当该变量所在的类被实例化后，可通过实例化的类名直接访问。 共享方式 ：静态变量是全局变量，被所有类的实例对象共享，即一个实例的改变了静态变量的值，其他同类的实例读到的就是变化后的值； 实例变量是局部变量，不共享的。 window.onload和DOMContentLoaded的区别浏览器的渲染过程 用JS创建10个标签，点击的时候弹出对应的序号作用域 简述如何实现一个模块加载器，实现类型require.js的功能JS模块化 实现数组的随机排序 快速的让一个数组乱序 JS的基本算法 JS有哪些内置函数？–数据封装类对象内置函数Object、Array、Boolean、Number、String、Function、Date、RegExp、Error内置对象：JSON，Math. JS按照存储方式区分为哪些类型，并描述其特点。值类型:引用类型: 如何理解JSON？JSON只不过是一个JS对象而已常用的API:JSON.stringify({a:10,b:20})：把JSON对象变为字符串JSON.parse(‘{“a”:10,”b”:20}’)：把字符串变为JSON对象 如何准确判断一个变量是数组类型？instanceof方法。例如：var arr=[]arr instanceof Array//truetypeof arr//Objecttypeof只能准确判断值类型的具体类型，无法判断引用类型的具体类型 写一个原型链继承的例子描述new一个对象的过程 new一个对象的过程发生了什么 zepto(或其他框架)源码中如何使用原型链Java同步和异步的区别及各自的优缺点同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。异步则是可以提高效率了，现在cpu都是双核，四核，异步处理的话可以同时做多项工作，当然必须保证是可以并发处理的。 写一个线程安全的单例模型使用同步方法12345678910111 public class Singleton &#123; 2 private static Singleton instance; 3 private Singleton ()&#123;4 5 &#125; 6 public static synchronized Singleton getInstance()&#123; //对获取实例的方法进行同步7 if (instance == null) 8 instance = new Singleton();9 return instance;10 &#125;11 &#125; 使用双重同步锁1234567891011121314151 public class Singleton &#123; 2 private static Singleton instance; 3 private Singleton ()&#123; 4 &#125; 5 public static Singleton getInstance()&#123; //对获取实例的方法进行同步 6 if (instance == null)&#123; 7 synchronized(Singleton.class)&#123; 8 if (instance == null) 9 instance = new Singleton();10 &#125;11 &#125;12 return instance;13 &#125;14 15 &#125; HashMap,Hashset,arraylist,linklist,vevtor总结多线程中出现的问题等等啥数据库的隔离级别 Read Uncommitted（未提交读） 这是事务最低的隔离级别，它写事务阻止其他写事务，避免了更新遗失，但允许另外一个事务可以读到这个事务未提交的数据，会出现脏读。本隔离级别一般很少实际应用，因为他的性能也比不比其他级别好多少 Read Committed（提交读） 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这是大多数数据库的默认隔离级别（但不是MySQL默认的）。这种隔离级别的问题是————不可重复读（在同一事务中执行完全相同的sql语句可能看到不一样的结果） 产生这种情况的原因是：写事务会阻止其他读写事务。读事务不会阻止其他任何事务。 Repeatable Read（可重复读） 确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这是MySQL数据库的默认隔离级别。这种隔离级别可能出现的问题————幻读 产生这种情况的原因是：读事务会阻止其他写事务，但是不会阻止其他读事务。可重复读阻止的写事务包括update和delete（只给存在的表加上了锁），但是不包括insert（新行不存在，所以没有办法加锁），所以一个事务第一次读取可能读取到了10条记录，但是第二次可能读取到11条，这就是幻读。 Serializable（可串行化）这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫串行化。在这个级别，可能导致大量的超时现象和锁竞争。 抽象类和接口的区别?具体的使用场景？ 抽象类和接口的区别及使用场景 如何实现数组去重如何实现轮播图（原生JS实现）JS数据类型有哪些CSS选择器以及优先级]]></content>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js学习笔记]]></title>
    <url>%2F2017%2F11%2F07%2FNode-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[了解Node.js简单的说 Node.js 就是运行在服务端的 JavaScript。是一个事件驱动I/O服务端JavaScript环境，基于Chrome的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。可以经常逛一逛下面这些网站来了解Node.js:nodejs.orgnpmjs.comwww.github.comwww.stackoverflow.com 安装Node.js(Node.js版本一定要和Node.js API一致)版本号奇数为非稳定版，偶数为稳定版]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库查询]]></title>
    <url>%2F2017%2F11%2F06%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[MySQL查询的5种子句：where(条件查询)、having(筛选)、group by(分组)、order by(排序)、limit(限制结果数) 连接查询连接查询：将多张表(&gt;=2)进行记录的连接(按照某个指定的条件进行数据拼接)。连接查询的意义: 在用户查看数据的时候,需要显示的数据来自多张表. 内连接（inner join） INNER JOIN定义：在查询的几个表中，每个表都存在至少一个匹配时，INNER JOIN 关键字返回行。也就是共有部分，即几个表的交集。 1SELECT * FROM table1 INNER JOIN table2 ON 查询条件; 外连接（outer jion） 左外连接(left outer jion) LEFT JOIN定义：关键字会从左表那里返回所有的行，即使在右表 中没有匹配的行，右表没有的都会显示NULL。 1SELECT * FROM table1(左表) LEFT JOIN table2(右表) ON 查询条件; 右外连接(right outer jion) RIGHT JOIN定义：关键字会右表那里返回所有的行，即使在左表中没有匹配的行，左表没有的都会显示NULL。 1SELECT * FROM table1(左表) RIGHT JOIN table2(右表) ON 查询条件; 完全外连接(full join) 是结合左连接与右连接的方式，会得到两表都会没有的记录，以NULL的形式显示，但是MySQL不支持。不过可以用UNION关键字来建立左连接与右连接 123SELECT * FROM table1(左表) LEFT JOIN table2(右表) ON 查询条件（注意不要有分号）UNIONSELECT * FROM table1(左表) RIGHT JOIN table2(右表) ON 查询条件; 自然连接(natural jion) 自然连接的作用：自动将表中相同的列进行匹配，同时排除掉重复出现的列，保证相同的列只出现一次。1SELECT * FROM table1 natural join table2; 子查询子查询是一个查询语句嵌套着另外的查询语句，用来进行一定层次的查询，其中子查询相当于第一步查询过滤，外查询就是最后得到结果的查询。 合并查询合并查询主要是UNION与UNION ALL两个，是将查询结果合并，但是必须满足：合并的列的数据与数据类型必须相同。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexoBlog托管在coding]]></title>
    <url>%2F2017%2F11%2F02%2FhexoBlog%E6%89%98%E7%AE%A1%E5%9C%A8coding%2F</url>
    <content type="text"><![CDATA[将Hexo托管到coding上1.如果没有coding账号，先注册。 2.在coding上创建一个项目（建议项目名和用户名相同），将属性设置为私有。如果第一次使用coding的话，需要设置SSH公钥。直接使用github生成的公钥即可。本地打开id_rsa.pub文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。 3.获取这个项目的SSH地址（在代码中可获取），配置hexo中的_config.yml的deploy下 3.添加后在git bash命令输入： 1ssh -T git@git.coding.net 如果得到下面提示就表示公钥添加成功： 1Coding.net Tips : [Hello ! You&apos;ve conected to Coding.net by SSH successfully! ] 4.使用部署命令就可以把博客同步到coding上： 1hexo deploy -g pages服务方式部署部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单就是在source/需要创建一个空白文件，至于原因，是因为 coding.net需要这个文件来作为以静态文件部署的标志。就是说看到这个Staticfile就知道按照静态文件来发布。 1cd source/ 1touch Staticfile 分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。 如果你的项目名称跟你coding的用户名一样， yourusername.coding.me就能访问博客，否则就要带上项目名：yourusername.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexoBlog</tag>
      </tags>
  </entry>
</search>
