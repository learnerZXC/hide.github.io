<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向过程和面向对象的区别]]></title>
    <url>%2F2018%2F02%2F03%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[面向过程优点：性能比面向对象高，因为面向对象类的调用需要实例化，开销比较大，比较消耗资源；比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点：没有面向对象易维护、易复用、易扩展 面向对象有点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，使系统更加灵活、易于维护。 面向对象和面向过程的区别 多态的缺点：多态后不能使用子类特有的属性和方法。 多态的好处1减少代码量]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重写（override）和重载(overload)的区别]]></title>
    <url>%2F2018%2F02%2F03%2F%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1.重写（override）和重载(overload)的区别方法重载是让类以统一的方式处理不同数据类型的一种手段。多个同名函数同时存在，但具有不同的参数个数/类型。重载是一个类中多态的一种体现。 Java的方法重载，就是在一个类中可以创建多个方法，他们具有相同的名字，但有不同的参数和不同的定义。调用方法时通过传入参数的个数和类型来决定具体使用哪种方法，这就是多态性。 方法重写是父类和子类之间多态性的体现。子类对父类的方法进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Override)。在Java中，子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改。这就需要方法的重写。方法重写又称做方法覆盖。 如果子类的方法与父类中的某一方法具有相同的方法名、返回类型和参数表，则新方法覆盖原有的方法，如需要用父类中原有的方法，可以使用super关键字引用当前类的父类。 总结： 方法重写（override） 方法名、参数、返回值类型必须相同； 子类方法不能缩小父类方法的访问权限； 子类方法不能比父类方法抛出更多的异常（子类也可以不抛异常）； 存在于父类和子类之间； 被覆盖的方法不能为private,否则在子类中只是重新定义了一个方法，并没有对其进行覆盖； 方法被定义为final不能被重新。 方法重载（overload） 参数类型、个数、顺序至少有一个不一致（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）； 不能重载只有返回值不同的方法。 方法的异常类型和数目不会对重载造成影响； 存在于父类、子类和同类中； 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F02%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[设计原则 单一职责原则：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。 里氏替换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。 依赖倒置原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。 接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用。 开放-封闭原则：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 s 设计模式 策略模式——定义算法族，分别封装起来，让他们之间可以彼此替换，此模式让算法的变化独立于使用算法的客户。 观察者模式——在对象之间建立一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会接到通知，并自动更新。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造函数]]></title>
    <url>%2F2018%2F02%2F03%2F%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88constructor%EF%BC%89%E6%98%AF%E5%90%A6%E8%83%BD%E8%A2%ABOverride%2F</url>
    <content type="text"><![CDATA[构造器是干什么用的？构造器是用来生成一个类的实例并初始化这个实例用的。 构造器如何工作？Java在构造实例时的顺序如下： 分配对象空间，并将对象中成员初始化为0或者空，java不允许用户操纵一个不定值的对象。 执行属性值的显式初始化。 执行构造器。 将变量关联到堆中的对象上。 执行构造器的步骤可以分为以下几步： Bind构造器的参数 。 如果显式的调用了this，那就递归调用this构造器然后跳到步骤4 。 递归调用显式或者隐式的父类构造器，除了Object以外，因为它没有父类。 执行显式的实例变量初始化（也就是上边的流程中的第二步，调用返回以后执行，这个步骤相当于在父构造器执行后隐含执行的，看样子像一个特殊处理）。 ###构造器不可被override其实你只需要记住一句话：构造器不是方法，不能被子类继承。，所以Constructor也就不能被override。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造函数。用来修饰方法特性的所有修饰符都不能用来修饰构造器（并不等与构造器具备这些特性，虽然不能用static修饰构造器，但它却有静态特性）构造器只能用 public private protected这三个权限修饰符，且不能有返回语句。]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0入门]]></title>
    <url>%2F2018%2F02%2F03%2Fvue2.0%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"></content>
      <tags>
        <tag>vue2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吾日三省吾身]]></title>
    <url>%2F2018%2F02%2F03%2F%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[吾日三省吾身每天进步一点点 2018年共运动31天2018年共读书0本 2018-02-02 学会控制自己，冷静解决问题 遇到事情多问为什么 坚持锻炼第二十八天，加油！ 2018-02-01 选择了就继续走下去，犹豫只会耽搁时间 越看觉得自己不懂得越多 坚持锻炼第二十七天，加油！ 2018-01-31不拖延不敷衍 合理安排每件事，找到最适合自己的方法 每天梳理下自己学到的 坚持锻炼第二十六天，加油！ 2018-01-30认真规划，认真完成 昨晚睡的太迟了，不过完成了自己想要做的 今天表现的还不错，继续加油 坚持锻炼第二十五天，加油！ 2018-01-29每天早起先规划一下自己的任务，并去完成 终于又有一天早起了，希望坚持 做事情时集中精力，高效去完成 坚持锻炼第二十四天，加油！ 2018-01-28不要给自己想要做的事情找放弃的理由，因为一旦有一点松懈，就可能会因为懒惰而放弃 调整每天的状态，做到自律 以后还是尽量少把时间花在做饭上 坚持锻炼第二十三天，加油！ 2018-01-27 天气好冷今天，躲被窝就不想出来 来的票买好了，不用再想这方面的事了 坚持锻炼第二十二天，加油，相信可以一直坚持下去的 2018-01-26 晚上买了个服务器，研究了研究 又要买来的票了，又是一场战争 坚持锻炼第二十一天，加油，不知道二十一天养成习惯了吗，不过还是希望坚持下去 2018-01-25 早上要战胜寒冷，冲出被窝 今天下雪了，晚上出去看了看雪 坚持锻炼第二十天，加油 2018-01-24 加大每天读书时间，充分利用好时间 要能控制自己，拒绝拖延 坚持锻炼第十九天，加油！ 2018-01-23 遇到问题多尝试去解决，就会解决掉 多读书，看源码 坚持锻炼第十八天，加油！ 2018-01-22 做了自己想做的事情，加油 注意每天多读书 坚持锻炼第十七天，加油！ 2018-01-21最重要的不是做何选择，而是做了选择之后如何让去做 今天感觉时间都利用的挺好的，就是感觉时间不够用 越看的多越觉得自己会的少 坚持锻炼第十六天，加油！感觉这两天每天做完每组运动休息时间有点长，明天注意一下 2018-01-20不要怕做不出来，要努力去做，不做永远也做不出来 今天早上起迟了，不过起来之后都利用的挺好的，没有浪费时间 要快速进入状态，认真学习 坚持锻炼第十五天，加油！不知道养成一个习惯要多久 2018-01-19 晚上一不小心就睡过去了，导致一系列的计划都推迟了，要控制 遇到问题主动去解决，并总结下来 坚持锻炼第十四天，加油！ 2018-01-18想做的事情就要用于尝试去做 这两天表现都还挺好的，也没有咋浪费时间 寻找高效的方法，学会学习 坚持锻炼第十三天，加油！ 2018-01-17 保持状态，好好学习巩固基础 合理安排好时间，完成自己想要做的每一件事 坚持锻炼第十二天，加油！ 2018-01-16 今天白天表现基本不错，这两天晚上的表现都不是特别好。调整下 要抽出两小时看书 坚持锻炼第十一天，加油! 2018-01-15 今天白天表现基本不错，晚上头疼，睡了一个多小时. 今天没有抢到票 坚持锻炼第十天，加油! 2018-01-14最难的事情就是战胜自己 这个周末都荒废了，基本全玩游戏了 这周开始看第一本书，并好好总结 坚持锻炼第九天，终于看见两位数的影子了 2018-01-13坚持，不找借口 今天一天都没咋学习，需要静下心来，好好调整状态 开始看集合类源码，加油 坚持锻炼第八天。 2018-01-12静下心来认真做好自己想做的每一件事 静下心来，做好一天，并认真总结 学会调整状态 坚持锻炼第七天，离两位数不远了，坚持住 2018-01-11每天做好规划 感觉每天时间都利用的不够充分，每天做好规划，并按照计划完成 抢到了回家的票(^ _ ^) 坚持早起第三天，坚持锻炼第六天，加油 2018-01-10挑战自己 早上早起成功。状态也不错 晚上研究了回家的火车票，所以没有学习，也睡晚了。。 坚持锻炼第五天，希望明天可以早起，明天补个面试题，加油！ 2018-01-09不怕学的慢，就怕坚持不下来 今天早上起来了，不过还不够早 加强技能训练，不断完善知识树 坚持锻炼第四天 2018-01-08最大的挑战就是自己 什么时候才能早起，今晚稍微睡早点看能起来吗。 每天起床其实并不是有多累，其实就是那么一念间 坚持锻炼第三天 2018-01-07学会控制自己，按照自己的思想生活 一到周末就会晚睡晚起，得改掉这个习惯 今天下午跟晚上表现挺好的，坚持，加油！ 坚持锻炼第二天，多读书 2018-01-06合理安排好每一件事，劳逸结合 今天出来早上没起来之外表现都还挺好的 以后每天抽出点时间读读书，看一段时间得歇会眼睛，要不眼睛容易疼 坚持锻炼第一天。啥时候这个数字能大于10. 2018-01-05想要坚持一件事是真的难 早上没有起的特别早，明天争取7.30起床 晚上没有咋学习，看电视时间长了睡着了，以后晚上尽量不看电视了 运动又没做，睡起来迟了。以后规划好，坚持下去 2018-01-04时间都是挤出来的，好好规划，要不总觉得没有时间 今天把自己想做的都做了，坚持下去 昨天断的锻炼又开始了，继续坚持 今晚早早收拾好早睡，调整作息 2018-01-03感觉每天时间都不够用，合理安排好自己的每一天时间 晚上没有做运动 今天时间利用的倒挺好的，收获也蛮多。 最近晚上睡的有点晚了感觉 2018-01-02早起第一天，虽然还没能达到心中想要起的时间，但确实比之前早挺多的，新的一天，加油！ 今天一天表现还行，也没有浪费啥时间。就是再提高提高效率就好了 晚上去理了个发，所以少学了一会 坚持早起第一天，坚持运动第三天。也不知道坚持多少天能养成习惯 2018-01-01今天给自己想的任务可以说一个都没有完成吧，但是也算是努力去做了 昨晚又熬夜了，并且还是玩游戏。批评一下，下不为例 晚上吃饭还是没有熬过去，又睡着了。吃完饭后不能躺床上了，一躺就想睡觉 坚持运动第二天。以后立任务要结合实际，不能总是任务太多而做不完。 2017-12-31坚持自省第二天，希望能养成习惯 早上起的倒不是特别迟了，但是赖被窝好长时间。改掉这个坏习惯！ 17年最后一天了，过的还行吧，白天没有学习，不过晚上还利用的挺好的。 明天就是新的一年了，希望自己能够完成自己想要完成的东西。 2017-12-30好久没有自省过了，感觉坚持一件事情好难，什么时候才能做到坚持自己想做的事情。加油！ 早上起来的太迟了，昨晚睡得太早。还是早睡早起好，睡得迟既起的迟，精神状态还不好 下午的时间还利用的挺好的，不过还有进步空间。 要坚持锻炼，每天看一道面试题，加油！！！！！ 2017-11-06 今天面试完回来没有安排好路线，等公交浪费了挺长时间 得赶紧找点项目做 博客要每天总结学到的东西 2017-11-05 明天有个面试，加油！ 好像周末早睡早起就比较容易断了 总结的多线程还没有总结完 2017-11-01 吾日三省吾身断了好多天了，因为搬家断了一直没有续上，现在继续，加油 最近终于可以早起了，希望坚持下去 没有完成自己规定的任务，下次任务一定好好规划，争取完成 2017-10-18 这几天晚上睡得有点迟了，主要是早上起不来 以后尽量中午休息一会，晚上不能睡了，要好好加油 每天都没有完成指定好的任务，要把一天安排的充实一点 2017-10-17 早上虽然没有早起，但是已经比之前强了点，希望继续努力 下午学习效率还行，比之前有进步 晚上吃饭的时候看电视时间太长了，并且因为懒没有去跑步 2017-10-16 要坚持下来自己想要坚持的 减少看手机时间 静下心来，提高学习效率 2017-10-15 希望之前几天提到的不好的一定要改掉 连续下雨，看来跑步暂时是不行了 希望能静下心来，好好学习 2017-10-14 今天早上不仅没起来，还起的特别迟（啊啊啊啊，什么时候才能早起呀） 今天白天都没有好好学习，并且也没有好好吃饭（加油啊，一定不能再这样了） 晚上睡得迟了（下午吃完饭睡了一觉，以后尽量不这样，会形成恶性循环的） 2017-10-13 早上又没起来（其实也不算特别累，但就是没起来，希望明天这个不要再出现了） 感觉得保护保护眼睛，看一段歇一段时间 晚上没有跑步（因为去看房子了） 2017-10-12 早上又没有起来（前一天晚上睡觉的时候总想着一定起来） 学习效率不咋高，没有充分利用好晚上的时间，不过比之前晚上有了一点点进步了 晚上也没有跑步，或许因为下小雨，但其实还是因为自己懒了]]></content>
      <categories>
        <category>自省</category>
      </categories>
      <tags>
        <tag>自省</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔试题]]></title>
    <url>%2F2018%2F02%2F03%2F%E7%AC%94%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[笔试题JS中”==”和”===”的区别js中两个等号(==)和三个等号(===)的区别： “==”表示：equality -&gt; 等同 的意思，”==”使用两个等号时，如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较。 “===”表示：identity -&gt; 恒等 的意思，”===”使用三个等号时，是不需要做类型转换的，如果两边值的类型不同，就表示一定是不等的。 简单说明使用三个等号(===)的判断规则： （1）如果类型不同，就一定不相等 （2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断） （3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。 （4）如果两个值都是true，或是false，那么相等 （5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等 （6）如果两个值都是null，或是undefined，那么相等 简单说明使用两个等号(==)的判断规则： （1）如果两个值类型相同，再进行三个等号(===)的比较 （2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较： 1）如果一个是null，一个是undefined，那么相等 2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较 JS中使用typeof能得到哪些类型返回值类型：string类型，有可能是：string、number、boolean、undefined、object、function前4个是值类型，后2个是引用类型 java四种级别修饰符以及访问权限 public:用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问； protected: protected修饰符的修饰的成员变量和方法也称为受保护的成员变量和方法， 受保护的成员变量和方法可以在本类或同一个包中的其它类（包括子类）中通过类的实例进行访问，也可以被同一个包中的类或不同包中的类继承，但是不能在不同包中的其它类（包括子类）中通过父类的实例进行访问。可以通过子类的实例进行访问 default(friendly): 如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。 private:用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。注意：java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。 静态变量和实例变量（非静态变量）的区别 语法上：静态变量前要加static关键字，而实例变量前则不加。 内存分配：静态变量在应用程序初始化时，就存在于内存当中,直到它所在的类的程序运行结束时才消亡；而实例变量需要被实例化后才会分配内存。 生存周期：静态变量生存周期为应用程序的存在周期；实例变量的存在周期取决于实例化的类的存在周期。 调用方式：静态变量只能通过“类.静态变量名”调用，不推荐类的实例化后调用；实例变量当该变量所在的类被实例化后，可通过实例化的类名直接访问。 共享方式 ：静态变量是全局变量，被所有类的实例对象共享，即一个实例的改变了静态变量的值，其他同类的实例读到的就是变化后的值； 实例变量是局部变量，不共享的。 window.onload和DOMContentLoaded的区别浏览器的渲染过程 用JS创建10个标签，点击的时候弹出对应的序号作用域 简述如何实现一个模块加载器，实现类型require.js的功能JS模块化 实现数组的随机排序JS的基本算法 JS有哪些内置函数？–数据封装类对象内置函数Object、Array、Boolean、Number、String、Function、Date、RegExp、Error内置对象：JSON，Math. JS按照存储方式区分为哪些类型，并描述其特点。值类型:引用类型: 如何理解JSON？JSON只不过是一个JS对象而已常用的API:JSON.stringify({a:10,b:20})：把JSON对象变为字符串JSON.parse(‘{“a”:10,”b”:20}’)：把字符串变为JSON对象 如何准确判断一个变量是数组类型？instanceof方法。例如：var arr=[]arr instanceof Array//truetypeof arr//Objecttypeof只能准确判断值类型的具体类型，无法判断引用类型的具体类型 写一个原型链继承的例子描述new一个对象的过程zepto(或其他框架)源码中如何使用原型链Java同步和异步的区别及各自的优缺点同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。异步则是可以提高效率了，现在cpu都是双核，四核，异步处理的话可以同时做多项工作，当然必须保证是可以并发处理的。 写一个线程安全的单例模型使用同步方法12345678910111 public class Singleton &#123; 2 private static Singleton instance; 3 private Singleton ()&#123;4 5 &#125; 6 public static synchronized Singleton getInstance()&#123; //对获取实例的方法进行同步7 if (instance == null) 8 instance = new Singleton();9 return instance;10 &#125;11 &#125; 使用双重同步锁1234567891011121314151 public class Singleton &#123; 2 private static Singleton instance; 3 private Singleton ()&#123; 4 &#125; 5 public static Singleton getInstance()&#123; //对获取实例的方法进行同步 6 if (instance == null)&#123; 7 synchronized(Singleton.class)&#123; 8 if (instance == null) 9 instance = new Singleton();10 &#125;11 &#125;12 return instance;13 &#125;14 15 &#125; HashMap,Hashset,arraylist,linklist,vevtor总结多线程中出现的问题等等啥]]></content>
      <tags>
        <tag>笔试题</tag>
      </tags>
  </entry>
</search>
