---
title: 笔试题
date: {{data}}
tags: 笔试题
categories:
---

### 笔试题
#### JS中"=="和"==="的区别
js中两个等号(==)和三个等号(===)的区别：

1. "=="表示：equality -> 等同  的意思，"=="使用两个等号时，如果两边值的类型不同的时候，是要先先进行类型转换后，才能做比较。

2. "==="表示：identity -> 恒等 的意思，"==="使用三个等号时，是不需要做类型转换的，如果两边值的类型不同，就表示一定是不等的。

3. 简单说明使用三个等号(===)的判断规则：

（1）如果类型不同，就一定不相等

（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）

（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。

（4）如果两个值都是true，或是false，那么相等

（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等

（6）如果两个值都是null，或是undefined，那么相等

4. 简单说明使用两个等号(==)的判断规则：

（1）如果两个值类型相同，再进行三个等号(===)的比较

（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：

1）如果一个是null，一个是undefined，那么相等

2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较

#### JS中使用typeof能得到哪些类型
返回值类型：string类型，有可能是：string、number、boolean、undefined、object、function
前4个是值类型，后2个是引用类型


#### java四种级别修饰符以及访问权限
1. public:用public修饰的类、类属变量及方法，包内及包外的任何类（包括子类和普通类）均可以访问；
2. protected: protected修饰符的修饰的成员变量和方法也称为受保护的成员变量和方法， 受保护的成员变量和方法可以在本类或同一个包中的其它类（包括子类）中通过类的实例进行访问，也可以被同一个包中的类或不同包中的类继承，但是不能在不同包中的其它类（包括子类）中通过父类的实例进行访问。可以通过子类的实例进行访问
3. default(friendly):  如果一个类、类属变量及方法没有用任何修饰符（即没有用public、protected及private中任何一种修饰），则其访问权限为default（默认访问权限）。默认访问权限的类、类属变量及方法，包内的任何类（包括继承了此类的子类）都可以访问它，而对于包外的任何类都不能访问它（包括包外继承了此类的子类）。
4. private:用private修饰的类、类属变量及方法，只有本类可以访问，而包内包外的任何类均不能访问它。<br>
注意：java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。

#### 静态变量和实例变量（非静态变量）的区别
- 语法上：静态变量前要加static关键字，而实例变量前则不加。
- 内存分配：静态变量在应用程序初始化时，就存在于内存当中,直到它所在的类的程序运行结束时才消亡；而实例变量需要被实例化后才会分配内存。
- 生存周期：静态变量生存周期为应用程序的存在周期；实例变量的存在周期取决于实例化的类的存在周期。
- 调用方式：静态变量只能通过“类.静态变量名”调用，不推荐类的实例化后调用；实例变量当该变量所在的类被实例化后，可通过实例化的类名直接访问。
- 共享方式 ：静态变量是全局变量，被所有类的实例对象共享，即一个实例的改变了静态变量的值，其他同类的实例读到的就是变化后的值； 实例变量是局部变量，不共享的。

#### window.onload和DOMContentLoaded的区别
浏览器的渲染过程
#### 用JS创建10个<a>标签，点击的时候弹出对应的序号
作用域
#### 简述如何实现一个模块加载器，实现类型require.js的功能
JS模块化
#### 实现数组的随机排序
JS的基本算法
#### JS有哪些内置函数？--数据封装类对象
内置函数Object、Array、Boolean、Number、String、Function、Date、RegExp、Error
内置对象：JSON，Math.
#### JS按照存储方式区分为哪些类型，并描述其特点。
值类型:
引用类型:
#### 如何理解JSON？
JSON只不过是一个JS对象而已
常用的API:JSON.stringify({a:10,b:20})：把JSON对象变为字符串<br/>
JSON.parse('{"a":10,"b":20}')：把字符串变为JSON对象

#### 如何准确判断一个变量是数组类型？
instanceof方法。<br/>
例如：<br/>
`var arr=[]`<br/>
`arr instanceof Array//true`<br/>
`typeof arr//Object`<br/>
typeof只能准确判断值类型的具体类型，无法判断引用类型的具体类型
#### 写一个原型链继承的例子
#### 描述new一个对象的过程
#### zepto(或其他框架)源码中如何使用原型链

#### Java同步和异步的区别及各自的优缺点
同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；<br/>
异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。<br/>
同步可以避免出现死锁，读脏数据的发生，一般共享某一资源的时候用，如果每个人都有修改权限，同时修改一个文件，有可能使一个人读取另一个人已经删除的内容，就会出错，同步就会按顺序来修改。<br/>
异步则是可以提高效率了，现在cpu都是双核，四核，异步处理的话可以同时做多项工作，当然必须保证是可以并发处理的。

#### 写一个线程安全的单例模型
使用同步方法<br>
``` java
1 public class Singleton {  
2      private static Singleton instance;  
3      private Singleton (){
4          
5      }   
6      public static synchronized Singleton getInstance(){    //对获取实例的方法进行同步
7        if (instance == null)     
8          instance = new Singleton();
9        return instance;
10      }
11  }  
```
使用双重同步锁<br>
``` java
1 public class Singleton {  
 2      private static Singleton instance;  
 3      private Singleton (){
 4      }   
 5      public static Singleton getInstance(){    //对获取实例的方法进行同步
 6        if (instance == null){
 7            synchronized(Singleton.class){
 8                if (instance == null)
 9                    instance = new Singleton();
10            }
11        }
12        return instance;
13      }
14      
15  }
```

#### HashMap,Hashset,arraylist,linklist,vevtor
#### 总结多线程中出现的问题等等啥

#### 数据库的隔离级别
- Read Uncommitted（未提交读）

这是事务最低的隔离级别，它写事务阻止其他写事务，避免了更新遗失，但允许另外一个事务可以读到这个事务未提交的数据，会出现脏读。本隔离级别一般很少实际应用，因为他的性能也比不比其他级别好多少

- Read Committed（提交读）

保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这是大多数数据库的默认隔离级别（但不是MySQL默认的）。这种隔离级别的问题是————不可重复读（在同一事务中执行完全相同的sql语句可能看到不一样的结果）

产生这种情况的原因是：写事务会阻止其他读写事务。读事务不会阻止其他任何事务。

- Repeatable Read（可重复读）

确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这是MySQL数据库的默认隔离级别。这种隔离级别可能出现的问题————幻读

产生这种情况的原因是：读事务会阻止其他写事务，但是不会阻止其他读事务。可重复读阻止的写事务包括update和delete（只给存在的表加上了锁），但是不包括insert（新行不存在，所以没有办法加锁），所以一个事务第一次读取可能读取到了10条记录，但是第二次可能读取到11条，这就是幻读。

- Serializable（可串行化）
这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题
读加共享锁，写加排他锁。这样读取事务可以并发，但是读写，写写事务之间都是互斥的，基本上就是一个个执行事务，所以叫串行化。在这个级别，可能导致大量的超时现象和锁竞争。
