---
title: TCP/IP协议之HTTP协议
date: {{data}}
tags: HTTP协议
categories: TCP/IP协议
---

## TCP/IP协议之HTTP协议

### 简介

HTTP全称是HyperText Transfer Protocal，即：超文本传输协议。超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。<br/>
<!--more-->

从1990年开始就在WWW上广泛应用，是现今在WWW上应用最多的协议<br/>
Http是应用层协议。<br/>
HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。Http是一个基于请求/响应模式的、无状态的协议。即我们通常所说的Request/Response。

### HTTP协议的特点

1. 支持B/S及C/S模式
2. 简单快速：请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
3. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
4. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
5. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。

### HTTP工作原理
一次HTTP操作称为一个事务，其工作整个过程如下：<br/>
1. 地址解析<br/>
如用客户端浏览器请求这个页面：`http://localhost.com:8080/index.html`<br/>
从中分解出协议名、主机、端口、对象路径等部分，对于上面这个地址，解析得到结果如下：<br/>
协议名：http<br/>
主机名：localhost.com<br/>
端口：8080<br/>
对象路径：/index.html<br/>
在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。<br/>
2. 封装HTTP请求数据包<br/>
把以上部分结合本机自己的信息，封装成一个HTTP请求数据包。<br/>
3. 封装成TCP包，建立TCP连接（TCP的三次握手）<br/>
在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口。<br/>
4. 客户机发送请求命令<br/>
建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。<br/>
5. 服务器响应<br/>
服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。<br/>
实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。<br/>
6. 服务器关闭TCP连接<br/>
 一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码Connection:keep-alive，TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。



### HTTP协议之URL
HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息<br/>

URL,全称是Uniform&nbsp;Resource&nbsp;Locator, 中文叫统一资源定位符,是互联网上用来标识某一处资源的地址。以下面这个URL为例，介绍下普通URL的各部分组成：<br/>
`http://www.aspxfans.com:8080/news/index.asp?boardID=5&ID=24618&page=1#name`
从上面的URL可以看出，一个完整的URL包括以下几部分：
1. 协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“//”为分隔符

2. 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用

3. 端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口

4. 虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/”

5. 文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名

6. 锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分

7. 参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID=5&ID=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&”作为分隔符。
（原文：http://blog.csdn.net/ergouge/article/details/8185219 ）

### HTTP协议之Request
http请求由四部分组成，分别是：请求行、请求头部、空行、请求正文<br/>
HTTP的请求方式包括如下几种：
- GET(请求获取Request-URI所标识的资源)
- POST(在Request-URI所标识的资源后附加新的数据)
- HEAD(请求获取由Request-URI所标识的资源的响应消息报头)
- PUT(请求服务器存储一个资源，并用Request-URI作为其标识)
- DELETE(请求服务器删除Request-URI所标识的资源)
- OPTIONS(请求查询服务器的性能，或者查询与资源相关的选项和需求)
- TRACK(请求服务器回送收到的请求信息，主要用于测试或诊断)
- CONNECT(保留将来使用)<br/>

GET请求为例如下：<br/>
`GET /562f25980001b1b106000338.jpg HTTP/1.1`<br/>
`Host    img.mukewang.com`<br/>
`User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64)`<br/> `AppleWebKit/537.36 (KHTML, like Gecko)`<br/> `Chrome/51.0.2704.106 Safari/537.36`<br/>
`Accept    image/webp,image/*,*/*;q=0.8`<br/>
`Referer    http://www.imooc.com/`<br/>
`Accept-Encoding    gzip, deflate, sdch`<br/>
`Accept-Language    zh-CN,zh;q=0.8`<br/>


  1. 第一部分，请求行：<br/>
    格式如下：<br/>
    方法 [空格] 请求URI [空格] 版本号 [回车换行]<br/>
    Method&nbsp;Request-URI&nbsp;HTTP-Version CRLF（CRLF表示回车和换行，除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。<br/>
    例如：GET&nbsp;/form.html&nbsp;HTTP/1.1&nbsp;(CRLF)
  2. 第二部分，请求头部。紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。<br/>
  从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等。<br/>
  3. 第三部分：空行，请求头部后面的空行是必须的<br/>
  即使第四部分的请求数据为空，也必须有空行。<br/>
  4. 第四部分：请求数据也叫主体，可以添加任意的其他数据。<br/>
  这个例子的请求数据为空。<br/>
### HTTP协议之Response
一般般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。<br/>
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。<br/>
一个完整的response如下：<br/>
`HTTP/1.1 200 OK`<br/>
`Date: Fri, 22 May 2009 06:07:21 GMT`<br/>
`Content-Type: text/html; charset=UTF-8`<br/>
`空行`<br/>
`<html>`<br/>
  `<head></head>`<br/>
  `<body>`<br/>
      `<!--body goes here-->`<br/>
  `</body>`<br/>
`</html>`<br/>

1. 第一部分，状态行。<br/>
格式如下：<br/>
版本号 [空格] 状态码 [空格] 原因 [回车换行]<br/>
例子中（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）
2. 第二部分，消息报头，用来说明客户端要使用的一些附加信息。<br/>
例子中第二行和第三行为消息报头，
Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8<br/>
3. 第三部分，空行，消息报头后面的空行是必须的<br/>
4. 第四部分，响应正文，服务器返回给客户端的文本信息。<br/>
空行后面的html部分为响应正文。<br/>
#### HTTP状态码
状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br/>
  - 1xx：指示信息--表示请求已接收，继续处理<br/>
    - 100——客户必须继续发出请求<br/>
    - 101——客户要求服务器根据请求转换HTTP协议版本<br/>
  - 2xx：成功--表示请求已被成功接收、理解、接受
    - 200——交易成功
    - 201——提示知道新文件的URL
    - 202——接受和处理、但处理未完成
    - 203——返回信息不确定或不完整
    - 204——请求收到，但返回信息为空
    - 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件
    - 206——服务器已经完成了部分用户的GET请求
  - 3xx：重定向--要完成请求必须进行更进一步的操作
    - 300——请求的资源可在多处得到
    - 301——删除请求数据
    - 302——在其他地址发现了请求数据
    - 303——建议客户访问其他URL或访问方式
    - 304——客户端已经执行了GET，但文件未变化
    - 305——请求的资源必须从服务器指定的地址得到
    - 306——前一版本HTTP中使用的代码，现行版本中不再使用
    - 307——申明请求的资源临时性删除
  - 4xx：客户端错误--请求有语法错误或请求无法实现
    - 400——错误请求，如语法错误
    - 401——未授权
      - HTTP 401.1 - 未授权：登录失败
      - HTTP 401.2 - 未授权：服务器配置问题导致登录失败
      - HTTP 401.3 - ACL 禁止访问资源
      - HTTP 401.4 - 未授权：授权被筛选器拒绝
      - HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败
    - 402——保留有效ChargeTo头响应
    - 403——禁止访问
      - HTTP 403.1 禁止访问：禁止可执行访问
      - HTTP 403.2 - 禁止访问：禁止读访问
      - HTTP 403.3 - 禁止访问：禁止写访问
      - HTTP 403.4 - 禁止访问：要求 SSL
      - HTTP 403.5 - 禁止访问：要求 SSL 128
      - HTTP 403.6 - 禁止访问：IP 地址被拒绝
      - HTTP 403.7 - 禁止访问：要求客户证书
      - HTTP 403.8 - 禁止访问：禁止站点访问
      - HTTP 403.9 - 禁止访问：连接的用户过多
      - HTTP 403.10 - 禁止访问：配置无效
      - HTTP 403.11 - 禁止访问：密码更改
      - HTTP 403.12 - 禁止访问：映射器拒绝访问
      - HTTP 403.13 - 禁止访问：客户证书已被吊销
      - HTTP 403.15 - 禁止访问：客户访问许可过多
      - HTTP 403.16 - 禁止访问：客户证书不可信或者无效
      - HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效
    - 404——没有发现文件、查询或URl
    - 405——用户在Request-Line字段定义的方法不允许
    - 406——根据用户发送的Accept拖，请求资源不可访问
    - 407——类似401，用户必须首先在代理服务器上得到授权
    - 408——客户端没有在用户指定的饿时间内完成请求
    - 409——对当前资源状态，请求不能完成
    - 410——服务器上不再有此资源且无进一步的参考地址
    - 411——服务器拒绝用户定义的Content-Length属性请求
    - 412——一个或多个请求头字段在当前请求中错误
    - 413——请求的资源大于服务器允许的大小
    - 414——请求的资源URL长于服务器允许的长度
    - 415——请求资源不支持请求项目格式
    - 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段
    - 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。
  - 5xx：服务器端错误--服务器未能实现合法的请求
    - HTTP 500 - 内部服务器错误
      - HTTP 500.100 - 内部服务器错误 - ASP 错误
      - HTTP 500-11 服务器关闭
      - HTTP 500-12 应用程序重新启动
      - HTTP 500-13 - 服务器太忙
      - HTTP 500-14 - 应用程序无效
      - HTTP 500-15 - 不允许请求 global.asa
    - Error 501 - 未实现
    - HTTP 502 - 网关错误

### HTTP协议之请求头
HTTP最常见的请求头如下：
- Accept:浏览器可接受的MIME类型；
- Accept-charset：浏览器可接受的字符集；
- Accept-Encoding: 浏览器能够解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间；
- Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到；
- Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中；
- Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小；
- Content-Length：表示请求消息正文的长度；
- Cookie：这是最重要的请求头信息之一；
- From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它；
- Host：初始URL中的主机和端口；
- If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答；
- pragma：定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝；
- Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
- User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用；
- UA-Pixel,UA-Color,UA-OS,UA-CPU:由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。

### HTTP之响应头
HTTP最常见的响应头如下所示：<br/>
- Allow：服务器支持哪些请求方法（如GET、POST等）；
- Content-Type：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和NAME类型的对应关系；
- Content-Encoding：文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader("Accept-Encoding")）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面；
- Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容；
- Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦；
- Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。
- Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置；
- Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302；
- Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过`setHeader("Refresh", "5; URL=http://host/path")`让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的`<META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path">`实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是<META HTTP-EQUIV="Refresh" ...>。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。

###HTTP之实体头
实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。<br/>
- Allow：GET,POST；
- Content-Encoding：文档的编码（Encode）方法，例如gzip,见“HTTP之响应头”；
- Content-Language：内容的语言类型，例如：zh-cn；
- Content-Length：表示内容长度，eg:80,可见“HTTP之响应头”；
- Content-Location：表示客户应当到哪里去提取文档，可见“HTTP之响应头”；
- Content-MD5：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较；
- Content-Range：随部分实体一同发送；标明被插入字节的低位与高位字节偏移，也标明此实体的总长度；
- Content-Type：标明发送或者接收的实体的MIME类型；
-  Expires：为0证明不缓存；
- Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.

### HTTP之扩展头
在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。<br/>
现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。
- Refresh：1;url=http://www.dfdf.org  //过1秒跳转到指定位置；
- Content-Disposition：头字段,可参考“2.5响应头”；
- Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。

###   GET方式和POST方式的区别：
GET方式：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。<br/>
POST方式：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：<br/>
 - 对现有资源的解释；<br/>
 - 向电子公告栏、新闻组、邮件列表或类似讨论组发信息；<br/>
 - 提交数据块；<br/>
 - 通过附加操作来扩展数据库 。<br/>
从上面描述可以看出，Get是向服务器发索取数据的一种请求；而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。<br/>
GET方式和POST方式有以下区别：
    1. 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。
    2. get和post理论上都没有数据大小限制，但是浏览器本身对url长度有限制，IE为2083B，火狐、chrome等为4098B。post数据时无论多大都不会报错，而是浏览器会崩溃。还有服务器端对数据大小可能会有限制。
    3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
    4. 安全性问题。正如在（1）中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好。
    5. 安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了（比方说文章下面出现一条注解）。

### URI和URL的区别
URI（Uniform Resource Identifier）是统一资源标识符，而URL（Uniform Resource Location）是统一资源定位符。因此，笼统地说，每个URL都是URI，但不一定每个URI都是 URL。这是因为URI还包括一个子类，即统一资源名称(URN)，它命名资源但不指定如何定位资源。区别如下：
- 在Java类库中，URI类不包含任何访问资源的方法，它唯一的作用就是解析。相反的是，URL类可以打开一个到达资源的流。
- Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的，URI一般由三部组成:<br/>
  1. 访问资源的命名机制
  2. 存放资源的主机名
  3. 资源自身的名称，由路径表示，着重强调于资源。
- URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。<br/>
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL一般由三部组成:<br/>
  1. 协议(或称为服务方式)
  2. 存有该资源的主机IP地址(有时也包括端口号)
  3. 主机资源的具体地址。如目录和文件名等

### Session和Cookie的区别
Cookie和Session都为了用来保存状态信息，都是保存客户端状态的机制，它们都是为了解决HTTP无状态的问题而所做的努力。<br/>

Session可以用Cookie来实现，也可以用URL回写的机制来实现。用Cookie来实现的Session可以认为是对Cookie更高级的应用。<br/>

Session和Cookie区别：
- Cookie将状态保存在客户端，Session将状态保存在服务器端；
- Cookies是服务器在本地机器上存储的小段文本并随每一个请求发送至同一个服务器。Cookie最早在RFC2109中实现，后续RFC2965做了增强。网络服务器用HTTP头向客户端发送cookies，在客户终端，浏览器解析这些cookies并将它们保存为一个本地文件，它会自动将同一服务器的任何请求缚上这些cookies。Session并没有在HTTP的协议中定义；
- Session是针对每一个用户的，变量的值保存在服务器上，用一个sessionID来区分是哪个用户session变量,这个值是通过用户的浏览器在访问的时候返回给服务器，当客户禁用cookie时，这个值也可能设置为由get来返回给服务器；
- 就安全性来说：当你访问一个使用session 的站点，同时在自己机子上建立一个cookie，建议在服务器端的SESSION机制更安全些.因为它不会任意读取客户存储的信息。

### HTTP协议是无状态的和Connection:keep-alive的区别
状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系<br/>

HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）<br/>

从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接<br/>
 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间<br/>
